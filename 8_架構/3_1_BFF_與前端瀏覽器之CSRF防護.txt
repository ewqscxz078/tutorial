ref ChatGPT

前端瀏覽器與 BFF 之 CSRF 防護。
	* BFF 用 Session Cookie 跟瀏覽器互動，本質上不是在「做 OAuth2」，而是在「做傳統 Web 登入態」
	* OAuth2 / Access Token 那一套，是 BFF「對後端」才會用到的事。

	三個世界切乾淨
		① 瀏覽器世界（Browser）

			* 只懂：Cookie

			* 會自動送 Cookie

			* 不該保管 Access Token

			* 不該理解 OAuth2 細節

		② BFF 世界（你的 Spring Boot 4）

			* 同時活在兩個世界

			* 對瀏覽器：像傳統 MVC Web

			* 對後端 API：像 OAuth2 Client

		③ 後端資源世界（Resource Server）

			* 只認：JWT / Access Token

			* 不認 Session

			* 不認 Cookie（或只當普通 header）
	
	BFF「跟瀏覽器」到底在互動什麼？
		
		答案是：「登入狀態」不是「Token」
			在 BFF 模式下：

				* 瀏覽器 從頭到尾都沒看過 access token

				* 瀏覽器只知道：

					「我現在是不是登入狀態？」

				* 這個「登入狀態」就是 Session Cookie。
		
		實際流程
		
			Step 1：使用者從瀏覽器進 Portal
				
				Browser ── GET / ──▶ BFF
			
				還沒登入，BFF 會導向 IdP。
			
			Step 2：BFF 代表瀏覽器去跑 OIDC
				Browser ── redirect ──▶ Auth Server
				Browser ◀─ redirect ── BFF (/login/oauth2/code/xxx)
			
				這一步 是 BFF 在做 OAuth2 Client
				不是瀏覽器在做。
			
			Step 3：BFF 登入成功後「做一件關鍵的事」
			
				👉 建立 Session
					HttpSession {
					  SecurityContext {
						Authentication {
						  principal = OidcUser
						  authorities = [...]
						}
					  }
					}
				
				然後回應瀏覽器：
					Set-Cookie: JSESSIONID=abc123; HttpOnly; Secure; SameSite=Lax

			Step 4：之後瀏覽器每次呼叫 BFF API
				Browser ── GET /api/profile
						   Cookie: JSESSIONID=abc123 ──▶ BFF

				瀏覽器心裡想的是：
					「我帶 cookie 啦，我是登入的」
			
			Step 5：BFF 收到 request 時實際做的事
				1.Spring Security 用 cookie 找到 session

				2.從 session 拿出 SecurityContext

				3.確認使用者已登入

				4.如果需要呼叫後端系統 → 才拿 access token
		
		那 access token 在哪裡？
			[BFF Server Memory / Session / OAuth2AuthorizedClientService]
			  └── access_token
			  └── refresh_token

			* 只存在 BFF

			* 永遠不會送到瀏覽器

			* 用來呼叫：
				BFF ── Authorization: Bearer xxx ──▶ Resource Server

	為什麼這樣設計反而更安全？
		
		對瀏覽器
			* 沒 token

			* XSS 就算成功，也拿不到 access token

			* 攻擊面縮小

		對你（後端）
			* OAuth2 / Token Exchange / Refresh 都集中在 BFF

			* 前端不用知道任何 OAuth2 細節

			* 子系統權限、續期邏輯好控
	
	關鍵對照表
		| 問題                      | BFF 架構的答案                  |
		| ------------------------- | ------------------------------- |
		| 瀏覽器怎麼知道自己登入？  | Session Cookie                  |
		| 瀏覽器有 access token 嗎？| ❌ 沒有                         |
		| 瀏覽器能看到 JWT 嗎？     | ❌ 不能                         |
		| BFF 怎麼知道是誰？        | 從 Session 裡的 SecurityContext |
		| BFF 怎麼打後端 API？      | 用自己保管的 access token       |
		| CSRF 為什麼要做？         | 因為 Cookie 會自動帶            |


CSRF Token 不是用來證明「這個 request 是我 BFF 發的」
	而是用來證明：
	👉「這個 request 的發送者 能同時讀到 cookie + 自己產生 header」

先講清楚：CSRF 防的是什麼？

	CSRF 的攻擊模型是這樣的

		* 使用者已登入 BFF（瀏覽器有 JSESSIONID）

		* 使用者誤點惡意網站 evil.com
		* evil.com 發送 POST https://bff/api/transfer

		* 瀏覽器「自動」帶上：
			Cookie: JSESSIONID=abc123   ← 攻擊點

		👉 攻擊者拿不到 cookie，但不需要拿到
		👉 因為瀏覽器會幫他帶

	CSRF Token 真正的設計邏輯（這是關鍵）
	Spring Security 的 CSRF 保護用的是「雙重驗證來源」
		
		同一個 token，必須同時存在於：
			1.Cookie（瀏覽器自動帶）
			2.Request Header（JS 手動加）
				Cookie: XSRF-TOKEN=xyz
				Header: X-XSRF-TOKEN: xyz
			
			👉 兩邊必須相同，才放行
		
		那 CookieCsrfTokenRepository 到底做了什麼？
			.csrf(csrf -> csrf
			  .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
			)
			
			它做三件事：
				① BFF 產生一個隨機 CSRF token
					xyz-123-abc
				
				② BFF 回給瀏覽器（Set-Cookie）
					Set-Cookie: XSRF-TOKEN=xyz-123-abc; Secure; SameSite=Lax
				
					⚠️ 刻意不是 HttpOnly
						→ 讓前端 JS 能 document.cookie 讀到
				
				③ BFF 要求「之後每次改動狀態的請求」
					
					必須滿足：
						POST /api/xxx
						Cookie: JSESSIONID=abc123
						Cookie: XSRF-TOKEN=xyz-123-abc
						Header: X-XSRF-TOKEN=xyz-123-abc
			
			為什麼這樣可以防 CSRF？
				* 攻擊者只能「逼瀏覽器送 cookie」，
				* 但「不能逼瀏覽器幫他產生自訂 header」。
			
			「cookie 不會被挾持然後偽造發送嗎？」
				
				情境一：純 CSRF 攻擊（最常見）
					* 攻擊者網站 ❌ 讀不到你的 cookie

					* 只能發 <form> / <img> / <script>

					* ❌ 沒辦法設定 X-XSRF-TOKEN header
				
					👉 CSRF 失敗
				
				情境二：cookie 被「網路攔截」？
					* HTTPS + Secure cookie

					* ❌ 中間人拿不到 cookie
				
					👉 不是 CSRF 範疇，是 TLS 問題
				
				情境三：XSS（這是唯一真的危險的）
					* 如果你的網站有 XSS

					* 攻擊者 JS 可以：
						* 讀 cookie（因為 CSRF cookie 不是 HttpOnly）

						* 發 request + header
					👉 CSRF 擋不了 XSS

					⚠️ 但這不是 CSRF 的問題
					👉 任何前端 token 架構，XSS 都是致命的
			
			所以 CSRF Token 在「證明」什麼？
				不是證明：

					❌「request 是 BFF 發的」
					❌「cookie 沒被偷」

				而是證明：

					✅「這個 request 是在 我的前端 JS 執行環境中 主動組出來的」
					✅「不是第三方網站單純利用瀏覽器自動帶 cookie」
			
			一個超精準的比喻
				你可以把 CSRF token 想成：

					「請你在信封（cookie）裡的密碼，
					再用你自己的手（JS）抄一次貼在信封外（header）」

				* 旁人只能寄信（cookie）

				* 但抄不了密碼（header）
			
			完整心智模型
				BFF + Session + CSRF 的真相是：

					* Cookie ≠ 安全

					* Cookie + Header「同值」＝ 同源 JS 行為

					* CSRF Token 是 同源證明，不是身份證

可以問自己這 3 個檢查題：

	攻擊者網站能不能加 X-XSRF-TOKEN header？
		👉 ❌ 不能

	只有 cookie 沒 header，BFF 會不會拒絕？
		👉 ✅ 會

	Token 是否只由 BFF 產生、BFF 驗證？
		👉 ✅

	全部 yes → 你理解完全正確了


BFF 用 session ，橫向擴展
	不要用 in-memory session → 用集中式 session store。
		
		為什麼「預設 session」真的會卡死擴展？
			Spring Boot 預設是：
				JVM memory
				└── HttpSession
			如果你有：
				BFF-1   BFF-2   BFF-3
			
			那請求這樣走：
				Request #1 → BFF-1 → session OK
				Request #2 → BFF-2 → ❌ 找不到 session
		
		正解：Spring Session
			正確架構長這樣
				Browser
				  │
				  ▼
				Load Balancer
				  │
				  ▼
				BFF-1 ─┐
				BFF-2 ─┼─▶ Redis / JDBC
				BFF-3 ─┘
		
		在 Spring Boot 4 要怎麼做？
			1.引入 Spring Session（最常見是 Redis）
				<dependency>
				  <groupId>org.springframework.session</groupId>
				  <artifactId>spring-session-data-redis</artifactId>
				</dependency>
			
			2.設定 session 儲存策略
				spring:
				  session:
					store-type: redis
					timeout: 30m

			你不需要：
				* 改 Controller
				* 改 SecurityFilterChain
				* 改 CSRF 設定
		
		那 OAuth2 / access token 放哪？
			Spring Security 會幫你做這件事：
				HttpSession
				└── OAuth2AuthorizedClient
					├── access_token
					└── refresh_token
			👉 當你換成 Spring Session + Redis：
				* token 自動跟著進 Redis
				* 任一台 BFF 都能 refresh token
				* 完全支援 token rotation
		
		CSRF Token 會不會壞掉？
			不會。
			因為：
				CSRF Token
				  ├── Cookie (XSRF-TOKEN)
				  └── Session (expected value)
				
				Session 移到 Redis 只是「存的位置換了」，邏輯不變。
			
		那效能怎麼辦？Session 很重嗎？
			實務經驗給你參考（重點）
				* BFF 的 session 通常只存：
					* 使用者 ID
					* roles / authorities
					* OAuth2 tokens（幾 KB）
				* Redis RTT：~1ms（同區域）
				* 比起：
					* 每次 JWT 驗簽
					* 每次 call IdP introspection
						👉 實務上 session 成本更低
		
		那乾脆用 JWT 當 session 不就好了？
			你可以，但你會失去這些東西：
				| 能力           | Session  | JWT           |
				| -------------- | -------- | ------------- |
				| 立即登出       | ✅       | ❌（要黑名單） |
				| Token rotation | ✅       | ❌            |
				| 強制失效       | ✅       | ❌            |
				| 中央控管       | ✅       | ❌            |
				| BFF 好處       | ✅       | ❌            |
			
			👉 這也是為什麼 BFF + Session 在企業是主流
		
		如果你真的不想 Redis？
			你還有兩條路（但都比較差）

			❌ Sticky Session
				* LB 綁 instance
				* Pod 掛了 session 全失
				* Kubernetes 不友善

			❌ 前端 JWT
				* 回到 SPA Bearer 模式
				* CSRF 簡單了，但安全責任全回前端