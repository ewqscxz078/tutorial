https://zh.wikipedia.org/wiki/Bash
https://dywang.csie.cyut.edu.tw/dywang/linuxProgram/node12.html
http://linux.vbird.org/linux_basic/0320bash.php

bash shell

===================================================================
========================= history =================================
===================================================================
~/.bash_history 記錄的是前一次登入以前所執行過的指令， 而至於這一次登入所執行的指令都被暫存在記憶體中，
當你成功的登出系統後，該指令記憶才會記錄到 .bash_history 當中

執行 history 第幾筆指令的意思
	![number]

執行 history 由最近的指令向前搜尋『指令串開頭為 command』的那個指令，並執行；
	![command]

執行 history 上一個指令(相當於按↑按鍵後，按 Enter)
	!!

===================================================================
========================= tab =====================================
===================================================================
自動補齊

===================================================================
========================= alias  ==================================
===================================================================
列舉所有指令別名
	alias

將聚合的指令變成命令別名
	alias [命令別名]='[複合指令]'
	ex:
		alias rm='rm -i'

取消別名
	unalias [命令別名]
	ex:
		unalias rm
===================================================================
========================= 萬用字元*  ==============================
===================================================================
ls -l /usr/bin/X*

===================================================================
=========== 是否為 Bash shell 的內建命令： type  ==================
===================================================================
type [-tpa] name
    ：不加任何選項與參數時，type 會顯示出 name 是外部指令還是 bash 內建指令
-t  ：當加入 -t 參數時，type 會將 name 以底下這些字眼顯示出他的意義：
      file    ：表示為外部指令；
      alias   ：表示該指令為命令別名所設定的名稱；
      builtin ：表示該指令為 bash 內建的指令功能；
-p  ：如果後面接的 name 為外部指令時，才會顯示完整檔名；
-a  ：會由 PATH 變數定義的路徑中，將所有含 name 的指令都列出來，包含 alias

===================================================================
===================== 指令過長延續輸入與快速編輯按鈕 ==============
===================================================================
$ cp /var/spool/mail/root /etc/crontab \
> /etc/fstab /root

[ctrl]+u/[ctrl]+k	分別是從游標處向前刪除指令串 ([ctrl]+u) 及向後刪除指令串 ([ctrl]+k)。
[ctrl]+a/[ctrl]+e	分別是讓游標移動到整個指令串的最前面 ([ctrl]+a) 或最後面 ([ctrl]+e)。

===================================================================
============================ 變數處理 =============================
===================================================================
變數內容若有空白字元可使用雙引號『"』或單引號『'』將變數內容結合起來，但
	雙引號內的特殊字元如 $ 等，可以保有原本的特性，如下所示：
		『var="lang is $LANG"』則『echo $var』可得『lang is zh_TW.UTF-8』
	單引號內的特殊字元則僅為一般字元 (純文字)，如下所示：
		『var='lang is $LANG'』則『echo $var』可得『lang is $LANG』

在一串指令的執行中，還需要藉由其他額外的指令所提供的資訊時，都是用来做命令替换用(commandsubstitution)的，可以使用
	反單引號『`指令`』或『$(指令)』
	1. `  ` 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高。但反单引号容易打错或看错。
	2. $()並不是所有shell都支持。

取消變數
	unset myname

變數內容刪除與取代
	${變數#關鍵字} 若變數內容從頭開始的資料符合『關鍵字』，則將符合的最短資料刪除
	${變數##關鍵字}	若變數內容從頭開始的資料符合『關鍵字』，則將符合的最長資料刪除

	${變數%關鍵字} 若變數內容從尾向前的資料符合『關鍵字』，則將符合的最短資料刪除
	${變數%%關鍵字}	若變數內容從尾向前的資料符合『關鍵字』，則將符合的最長資料刪除

	${變數/舊字串/新字串} 若變數內容符合『舊字串』則『第一個舊字串會被新字串取代』
	${變數//舊字串/新字串}	若變數內容符合『舊字串』則『全部的舊字串會被新字串取代』

變數的測試與內容替換
	測試 str 若不存在，則將 var 內容設定為 root，str 仍為不存在的變數值
		var=${str-root}
	測試 str 不存在或為空字串，則將 var 內容設定為 root，str 仍為不存在的變數值
		var=${str:-root}

	測試 str 若不存在，則將 var 內容設定為 newvar，str 初始為 newvar
		unset str; var=${str=newvar}
	測試 str 不存在或為空字串，則將 var 內容設定為 newvar，str 初始為 newvar
		unset str; var=${str:=newvar}

	測試 str 若不存在，則輸出錯誤訊息，反之正常賦值
		unset str; var=${str?無此變數}
	測試 str 不存在或為空字串，則輸出錯誤訊息，反之正常賦值
		unset str; var=${str:?無此變數}

===================================================================
====================== 環境變數\自訂變數 ==========================
===================================================================
列舉顯示環境變數
	env

列舉(環境變數\自訂變數)
	set

自訂變數 => 環境變數
	export [變數名稱]

列舉環境變數
	export

declare [-aixr] variable
-a  ：將後面名為 variable 的變數定義成為陣列 (array) 類型
-i  ：將後面名為 variable 的變數定義成為整數數字 (integer) 類型
-x  ：用法與 export 一樣，就是將後面的 variable 變成環境變數；
-r  ：將變數設定成為 readonly 類型，該變數不可被更改內容，也不能 unset

===================================================================
========================= if ======================================
===================================================================
# 一個條件判斷，分成功進行與失敗進行 (else)
if [ 條件判斷式 ]; then
	當條件判斷式成立時，可以進行的指令工作內容；
else
	當條件判斷式不成立時，可以進行的指令工作內容；
fi

if [ 條件判斷式一 ]; then
	當條件判斷式一成立時，可以進行的指令工作內容；
elif [ 條件判斷式二 ]; then
	當條件判斷式二成立時，可以進行的指令工作內容；
else
	當條件判斷式一與二均不成立時，可以進行的指令工作內容；
fi

===================================================================
========================= $ =======================================
===================================================================
/path/to/scriptname  opt1  opt2  opt3  opt4
       $0             $1    $2    $3    $4
$# ：代表後接的參數『個數』，以上表為例這裡顯示為『 4 』；
$@ ：代表『 "$1" "$2" "$3" "$4" 』之意，每個變數是獨立的(用雙引號括起來)；
$* ：代表『 "$1c$2c$3c$4" 』，其中 c 為分隔字元，預設為空白鍵， 所以本例中代表『 "$1 $2 $3 $4" 』之意。

顯示目前這個 Shell 的執行緒代號
	echo $$

上個執行指令的回傳值
	echo $?

===================================================================
========================= shift ===================================
===================================================================
echo "Total parameter number is ==> $#"
echo "Your whole parameter is   ==> '$@'"
shift   # 進行第一次『一個變數的 shift 』
echo "Total parameter number is ==> $#"
echo "Your whole parameter is   ==> '$@'"
shift 3 # 進行第二次『三個變數的 shift 』
echo "Total parameter number is ==> $#"
echo "Your whole parameter is   ==> '$@'"

[dmtsai@study bin]$ sh shift_paras.sh one two three four five six <==給予六個參數
Total parameter number is ==> 6   <==最原始的參數變數情況
Your whole parameter is   ==> 'one two three four five six'
Total parameter number is ==> 5   <==第一次偏移，看底下發現第一個 one 不見了
Your whole parameter is   ==> 'two three four five six'
Total parameter number is ==> 2   <==第二次偏移掉三個，two three four 不見了
Your whole parameter is   ==> 'five six'

===================================================================
========================= > >> ===================================
===================================================================
清掉檔案裡內容並寫入file
	>
append 檔案最後面
	>>

===================================================================
========================= process  ===============================
===================================================================
https://www.tecmint.com/keep-remote-ssh-sessions-running-after-disconnection/
https://www.itread01.com/p/126702.html

執行shell 方式有兩種
一種產生新的shell，然後執行
另一種是當前shell下執行，不再啟用其他shell

exec
source 都屬builtins commands
可man exec
man source

source 會在當前shell下執行
exce 會把當前shell process 切換到後面的執行命令，可保持PID不變 $?


netstat -tuln 來取得目前主機有啟動的服務

stat fileName #可查看詳細建利情況 相對ls

command1 ; command2 # 批次執行
command1 & command2 # 並行執行

===================================================================
========================= /dev/null ===============================
===================================================================
#簡單來說就是垃圾桶/黑洞，只進不出
	ex:內容輸出到標準輸出(畫面)上
		cat test.log

	ex:內容不輸出到標準輸出上
		cat test.log > /dev/null

	ex:如果test.txt文件不存在時，使用"cat test.txt"命令時，會輸出"cat: test.txt: No such file or directory"
		cat test.txt 2>/dev/null
			則就不會跳出錯誤輸出訊息

	ex:禁止標準輸出和標準錯誤的輸出
		cat filename 2>/dev/null >/dev/null

	ex:使用/dev/null 清除檔案內容
		cat /dev/null > [fileName]

https://blog.51cto.com/bovin/1863433
0表示標準輸入
1表示標準輸出
2表示標準錯誤輸出
> 默認為標準輸出重定向，與 1> 相同
2>&1 意思是把 標準錯誤輸出 重定向到 標準輸出.
&>file 意思是把 標準輸出 和 標準錯誤輸出 都重定向到文件file中

===================================================================
========================= file 交集 并集 差集 =====================
===================================================================
https://blog.csdn.net/yinxusen/article/details/7450213
一、交集
	sort a.txt b.txt | uniq -d

二、并集
	sort a.txt b.txt | uniq

三、差集
	a.txt - b.txt:

	sort a.txt b.txt b.txt | uniq -u

	b.txt - a.txt:

	sort b.txt a.txt a.txt | uniq -u

四、相关的解释
	使用sort可以将文件进行排序，可以使用sort后面的玲玲，例如 -n 按照数字格式排序，例如 -i 忽略大小写，例如使用-r 为逆序输出等

	uniq为删除文件中重复的行，得到文件中唯一的行，后面的命令 -d 表示的是输出出现次数大于1的内容 -u表示的是输出出现次数为1的内容，那么对于上述的求交集并集差集的命令做如下的解释：

	sort a.txt b.txt | uniq -d：将a.txt b.txt文件进行排序，uniq使得两个文件中的内容为唯一的，使用-d输出两个文件中次数大于1的内容，即是得到交集

	sort a.txt b.txt | uniq ：将a.txt b.txt文件进行排序，uniq使得两个文件中的内容为唯一的，即可得到两个文件的并集

	sort a.txt b.txt b.txt | uniq -u：将两个文件排序，最后输出a.txt b.txt b.txt文件中只出现过一次的内容，因为有两个b.txt所以只会输出只在a.txt出现过一次的内容，即是a.txt-b.txt差集

	对于b.txt-a.txt为同理

	https://blog.csdn.net/matrix_google/article/details/76071330

去交集
1.求交集
	cat file1 file2 | sort | uniq -d > intersection.out

2.从file1中去除交集
	cat file1 intersection.out | sort | uniq -u > file1-ineter.out
===================================================================
========================= explorer ================================
===================================================================
以window folder方式導覽目錄開啟當前目錄
explorer .

===================================================================
========================= 檔名 目錄 亂碼===========================
===================================================================
刪除Linux上中文亂碼檔案/資料夾
1. 透過 ls -i 找到檔案/資料夾代表的編號
ls -i       //查看檔案代表的編號
2. 再用 find 去找這個編號的檔案後刪除
//刪除單一檔案
find -inum 檔案編號(數字) -delete

//刪除整個資料夾
find -inum 檔案編號(數字) -exec rm -rf {} \;

===================================================================
========================= include shell ===========================
===================================================================
. file
source file

===================================================================
============================ map/array ============================
===================================================================
https://blog.csdn.net/xzw_123/article/details/42920371

declare -A map=(["100"]="1" ["200"]="2")

输出所有key
	echo ${!map[@]}

輸出所有value
	echo ${map[@]}

走訪map
	for key in ${!map[@]}
	do
		echo ${map[$key]}
	done
===================================================================
============================ group count技巧 ======================
===================================================================
https://stackoverflow.com/questions/380817/best-way-to-simulate-group-by-from-bash
取得網路 建立狀態為例
 ss -ant | awk '{print $1}' | sort | uniq -c

===================================================================
============================ 強制離開 =============================
===================================================================

exit 1
===================================================================
============================ 密碼與權限 ===========================
===================================================================
看 hosts
	vi /etc/hosts
看有多少帳號
	vi /etc/passwd

看有多少群組
	vi /etc/group

使用該 id 權限?
	su -l [id]

用 root 權限改別人密碼
	sudo passwd [id]

用 root 權限執行指令，輸入完會要求你的密碼，但須有root的group
	sudo [command]

查看當前 user uid、gid、groups
	id

===================================================================
============================ 大小寫 ===============================
===================================================================
var="Hello,Word"
# 把變數中的第一個字元換成大寫
echo ${var^}
# 把變數中的所有小寫字母，全部替換為大寫
echo ${var^^}
# 把變數中的第一個字元換成小寫
echo ${var,}
# 把變數中的所有大寫字母，全部替換為小寫
echo ${var,,}

===================================================================
============================ bash debug ===========================
===================================================================
執行期
	bash -x ./xxx.sh

in script
	set -x
