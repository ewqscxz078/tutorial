https://zh.wikipedia.org/wiki/Bash
https://dywang.csie.cyut.edu.tw/dywang/linuxProgram/node12.html
http://linux.vbird.org/linux_basic/0320bash.php

bash shell

===================================================================
========================= history =================================
===================================================================

~/.bash_history 記錄的是前一次登入以前所執行過的指令， 而至於這一次登入所執行的指令都被暫存在記憶體中，
當你成功的登出系統後，該指令記憶才會記錄到 .bash_history 當中

===================================================================
========================= tab =====================================
===================================================================

自動補齊

===================================================================
========================= 全域變數\區域變數 =======================
===================================================================
列舉區域變數
	set

列舉全域變數
	export
	
===================================================================
========================= cd ======================================
===================================================================
返回家目錄
	cd ~

返回上一次目錄
	cd -
	或
	cd $OLDPWD
	
===================================================================
========================= ls ======================================
===================================================================
ls -p | grep -v /  # 僅顯示file
ls -d */  # 僅顯示folder

ls -l  |grep "^-"|wc -l #計算檔案數
ls -l  |grep "^d"|wc -l #計算目錄數


ls -lah `find . -xdev -type f -name "*.java" -size +250k` # 列出超出250k的java程式
ls -lah `find . -xdev -type f -name "*.pdf" -size +5M`
ls -lah `find . -xdev -type f -name "*.pdf" -size +1G`

===================================================================
========================= if ======================================
===================================================================
# 一個條件判斷，分成功進行與失敗進行 (else)
if [ 條件判斷式 ]; then
	當條件判斷式成立時，可以進行的指令工作內容；
else
	當條件判斷式不成立時，可以進行的指令工作內容；
fi

if [ 條件判斷式一 ]; then
	當條件判斷式一成立時，可以進行的指令工作內容；
elif [ 條件判斷式二 ]; then
	當條件判斷式二成立時，可以進行的指令工作內容；
else
	當條件判斷式一與二均不成立時，可以進行的指令工作內容；
fi
===================================================================
========================= cp ======================================
===================================================================
# --reflink=auto 代表有使用到cow 的檔案系統 會加速 copy
	cp -r --reflink=auto "$fromdir" "$todir" 

# copy 檔案
cp sourcefile targetfile

# copy 目錄含相關子目錄
	cp -r sourcefile targetfile 

===================================================================
========================= rm ======================================
===================================================================
# 有加\代表執行原生指令
	\rm -rf 
	
# 代表有可能執行alias 自訂簡碼	
	rm -rf 

# 含砍目錄
	rm -r {fileName} 

#僅刪除內容
	> {file}
	
===================================================================
========================= $ =======================================
===================================================================
/path/to/scriptname  opt1  opt2  opt3  opt4
       $0             $1    $2    $3    $4
$# ：代表後接的參數『個數』，以上表為例這裡顯示為『 4 』；
$@ ：代表『 "$1" "$2" "$3" "$4" 』之意，每個變數是獨立的(用雙引號括起來)；
$* ：代表『 "$1c$2c$3c$4" 』，其中 c 為分隔字元，預設為空白鍵， 所以本例中代表『 "$1 $2 $3 $4" 』之意。

===================================================================
========================= shift ===================================
===================================================================
echo "Total parameter number is ==> $#"
echo "Your whole parameter is   ==> '$@'"
shift   # 進行第一次『一個變數的 shift 』
echo "Total parameter number is ==> $#"
echo "Your whole parameter is   ==> '$@'"
shift 3 # 進行第二次『三個變數的 shift 』
echo "Total parameter number is ==> $#"
echo "Your whole parameter is   ==> '$@'"

[dmtsai@study bin]$ sh shift_paras.sh one two three four five six <==給予六個參數
Total parameter number is ==> 6   <==最原始的參數變數情況
Your whole parameter is   ==> 'one two three four five six'
Total parameter number is ==> 5   <==第一次偏移，看底下發現第一個 one 不見了
Your whole parameter is   ==> 'two three four five six'
Total parameter number is ==> 2   <==第二次偏移掉三個，two three four 不見了
Your whole parameter is   ==> 'five six'

===================================================================
========================= > >> ===================================
===================================================================
清掉檔案裡內容並寫入file
	>
append 檔案最後面
	>>
	
===================================================================
========================= 特殊字眼處理 ============================
===================================================================
$()和 ` `
都是用来做命令替换用(commandsubstitution)的
各自的优缺点：
1. `  ` 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高。但反单引号容易打错或看错。

2. $()并不是所有shell都支持。

===================================================================
========================= process  ===============================
===================================================================
https://www.tecmint.com/keep-remote-ssh-sessions-running-after-disconnection/
https://www.itread01.com/p/126702.html

執行shell 方式有兩種
一種產生新的shell，然後執行
另一種是當前shell下執行，不再啟用其他shell

exec
source 都屬builtins commands
可man exec
man source

source 會在當前shell下執行
exce 會把當前shell process 切換到後面的執行命令，可保持PID不變 $?


netstat -tuln 來取得目前主機有啟動的服務

stat fileName #可查看詳細建利情況 相對ls

command1 ; command2 # 批次執行
command1 & command2 # 並行執行

===================================================================
========================= alias  ==================================
===================================================================
alias 列舉所有指令別名

===================================================================
========================= /dev/null ===============================
===================================================================
#簡單來說就是垃圾桶/黑洞，只進不出
	ex:內容輸出到標準輸出(畫面)上
		cat test.log
		
	ex:內容不輸出到標準輸出上
		cat test.log > /dev/null
		
	ex:如果test.txt文件不存在時，使用"cat test.txt"命令時，會輸出"cat: test.txt: No such file or directory"	
		cat test.txt 2>/dev/null
			則就不會跳出錯誤輸出訊息
			
	ex:禁止標準輸出和標準錯誤的輸出
		cat filename 2>/dev/null >/dev/null

	ex:使用/dev/null 清除檔案內容
		cat /dev/null > [fileName]

===================================================================
========================= file 交集 并集 差集 =====================
=================================================================== 
https://blog.csdn.net/yinxusen/article/details/7450213		
一、交集
	sort a.txt b.txt | uniq -d

二、并集
	sort a.txt b.txt | uniq 

三、差集
	a.txt - b.txt:

	sort a.txt b.txt b.txt | uniq -u

	b.txt - a.txt:

	sort b.txt a.txt a.txt | uniq -u

四、相关的解释
	使用sort可以将文件进行排序，可以使用sort后面的玲玲，例如 -n 按照数字格式排序，例如 -i 忽略大小写，例如使用-r 为逆序输出等

	uniq为删除文件中重复的行，得到文件中唯一的行，后面的命令 -d 表示的是输出出现次数大于1的内容 -u表示的是输出出现次数为1的内容，那么对于上述的求交集并集差集的命令做如下的解释：

	sort a.txt b.txt | uniq -d：将a.txt b.txt文件进行排序，uniq使得两个文件中的内容为唯一的，使用-d输出两个文件中次数大于1的内容，即是得到交集

	sort a.txt b.txt | uniq ：将a.txt b.txt文件进行排序，uniq使得两个文件中的内容为唯一的，即可得到两个文件的并集

	sort a.txt b.txt b.txt | uniq -u：将两个文件排序，最后输出a.txt b.txt b.txt文件中只出现过一次的内容，因为有两个b.txt所以只会输出只在a.txt出现过一次的内容，即是a.txt-b.txt差集

	对于b.txt-a.txt为同理
		
	https://blog.csdn.net/matrix_google/article/details/76071330		
	
去交集
1.求交集
	cat file1 file2 | sort | uniq -d > intersection.out

2.从file1中去除交集
	cat file1 intersection.out | sort | uniq -u > file1-ineter.out	
===================================================================
========================= explorer ================================
=================================================================== 
以window folder方式導覽目錄開啟當前目錄
explorer . 

===================================================================
========================= 檔名 目錄 亂碼===========================
===================================================================
刪除Linux上中文亂碼檔案/資料夾
1. 透過 ls -i 找到檔案/資料夾代表的編號
ls -i       //查看檔案代表的編號
2. 再用 find 去找這個編號的檔案後刪除
//刪除單一檔案
find -inum 檔案編號(數字) -delete 

//刪除整個資料夾
find -inum 檔案編號(數字) -exec rm -rf {} \; 
			
===================================================================
========================= include shell ===========================
===================================================================
. file
source file			
	
===================================================================
============================ map ==================================
===================================================================	
https://blog.csdn.net/xzw_123/article/details/42920371	
	
declare -A map=(["100"]="1" ["200"]="2")

输出所有key
	echo ${!map[@]}	
	
輸出所有value	
	echo ${map[@]}	
	
===================================================================
============================ group count技巧 ======================
===================================================================
https://stackoverflow.com/questions/380817/best-way-to-simulate-group-by-from-bash
取得網路 建立狀態為例
 ss -ant | awk '{print $1}' | sort | uniq -c
		