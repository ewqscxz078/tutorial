ref ChatGPT

åŸ·è¡Œæ¦‚è¦ç›®æ¨™: client A æ‰“ api header with jwt åˆ° client B
	client A
		1.è¨­å®š auth server åœ¨å“ª(application.yml)
		2.ç™¼èµ·è«‹æ±‚åˆ° å¾ AUTH server å–å¾— jwt
		3.ç™¼èµ·è«‹æ±‚åˆ° client B api with jwt
	client B
		1.client B è¨­å®š è®“ Spring Security çŸ¥é“ Auth Serverï¼ˆJWT ç™¼è¡Œè€…ï¼‰ (application.yml)
		2.ä¸¦åœ¨ client B api åƒæ•¸æœ‰ @AuthenticationPrincipal Jwt jwtï¼Œå‰‡ client B æ”¶åˆ°æœƒè‡ªè¡Œè‡ªå‹•é©—è­‰ jwt

	å‰‡ Spring Boot + Spring Security + Spring Authorization Server é è¨­åº•å±¤å·²ç¶“å¹«æˆ‘å€‘è‡ªå‹•è™•ç†å¥½
		èƒ½åšåˆ°ä¸å¯«ä»»ä½• JWT ç”¢ç”Ÿæˆ–é©—è­‰çš„ç¨‹å¼ç¢¼ï¼Œå»è®“ OAuth2 æµç¨‹å®Œæ•´é‹ä½œ
			å·²è‡ªå‹•å®Œæˆ
				åœ¨ Auth Server ç«¯ï¼ˆJWT ç”¢ç”Ÿï¼‰
					ğŸ” æ ¹æ“š RegisteredClient çš„è¨­å®šç”¢å‡º JWT
					ğŸ“¦ è‡ªå‹•ç”Ÿæˆ access tokenï¼ˆå« scopeã€subã€iatã€exp ç­‰ claimï¼‰
					ğŸ” ä½¿ç”¨é è¨­ï¼ˆæˆ–ä½ æŒ‡å®šçš„ï¼‰é‡‘é‘°å° JWT é€²è¡Œ RS256 ç°½å
					ğŸŒ æä¾› /oauth2/tokenã€/.well-known/jwks.json ç­‰æ¨™æº– endpoint

				åœ¨ Resource Server ç«¯ï¼ˆJWT é©—è­‰ï¼‰
					ğŸŒ è‡ªå‹•æ ¹æ“š issuer-uri æŠ“ .well-known/openid-configuration
					ğŸ“¥ æ“·å– jwks_uri ä¸¦ä¸‹è¼‰ Auth Server çš„ public key
					ğŸ” è§£æ HTTP Header ä¸­çš„ Bearer token
					ğŸ” é©—è­‰ JWT çš„ç°½ç« ã€æœ‰æ•ˆæœŸã€issuerã€audience
					ğŸ›‚ å°‡ scope claim æ˜ å°„æˆ SCOPE_xxx æ¬Šé™çµ¦ SecurityContext

			Auth Server åªéœ€ï¼š
				@Bean
				public RegisteredClientRepository registeredClientRepository() {
					// è¨­å®š client scopeã€grant type å°±å¥½
				}
			Resource Server åªéœ€ï¼š
				spring:
				  security:
					oauth2:
					  resourceserver:
						jwt:
						  issuer-uri: https://your-auth-server
			Spring Security + Authorization Server æœƒæŠŠæ•´å€‹ JWT flow æ¥ç®¡ï¼Œè®“ä½ èƒ½å°ˆå¿ƒè™•ç† API æˆæ¬Šã€scope æ§åˆ¶ã€client è¨»å†Š ç­‰æ‡‰ç”¨é‚è¼¯ã€‚


OAuth2 auth server
	ç®¡ç† clientIdã€client_secret æ–¹å¼ for Client Credentials æˆæ¬Šæ¨¡å¼
		ç®¡ç†æ–¹å¼			å„ªé»				ç¼ºé»					é©ç”¨æƒ…å¢ƒ
		InMemory ç¡¬ç·¨ç¢¼		å¿«é€Ÿã€ç°¡å–®			ç„¡æ³•è®Šæ›´ã€ä¸åˆ©ç¶­è­·		Demo / æ¸¬è©¦
		JDBC + å•Ÿå‹•åˆå§‹åŒ–	å½ˆæ€§é«˜ã€çµæ§‹æ¸…æ™°	åˆå§‹å°å…¥éœ€è¦å»ºè¡¨		æ­£å¼ç’°å¢ƒ/ä¸­å¤§å‹å°ˆæ¡ˆ
		è‡ªè¨‚ API è¨»å†Š		å‹•æ…‹ã€å®‰å…¨æ€§å¯æ§åˆ¶	å¯¦ä½œæˆæœ¬ç¨é«˜			SaaS / å¤šç§Ÿæˆ¶

	client_id / secret ç™¼æ”¾ç­–ç•¥é¸æ“‡
		æ–¹å¼					å„ªé»			ç¼ºé»					é©ç”¨æƒ…å¢ƒ
		æ‰‹å‹•æä¾› + å¯«å…¥ yml		æœ€ç°¡å–®			ä¸åˆ©æ›´æ–° / å¤šç’°å¢ƒ		æ¸¬è©¦ã€å°å‹ã€å›ºå®š client æ•¸é‡
		CI/CD ç§˜å¯†æ³¨å…¥			è‡ªå‹•åŒ–ã€å®‰å…¨	éƒ¨ç½²æ•´åˆè¼ƒè¤‡é›œ			å¤š microserviceã€å…§éƒ¨æœå‹™
		è‡ªè¨‚è¨»å†Š API			å½ˆæ€§é«˜			å®‰å…¨éœ€æ§ç®¡				å¤–éƒ¨åˆä½œæ–¹ã€SaaS æ¨¡å¼
		ç”¢å‡ºæª”æ¡ˆ / é…ç½®åŒ¯å‡º		å¯æ§ã€æ˜“æ•´åˆ	ç®¡ç†èˆ‡åŠ å¯†éœ€è€ƒé‡		å‚³çµ±æ¶æ§‹ã€åŠè‡ªå‹•åŒ–å ´æ™¯

	ç®¡ç† clientIdã€client_secret æ–¹å¼æ˜¯ä½¿ç”¨ JDBC + å•Ÿå‹•åˆå§‹åŒ– æ–¹å¼ï¼Œå¦‚ä½•è®“ CI/CD ç§˜å¯†æ³¨å…¥åˆ°å°æ‡‰çš„æœå‹™?
		[CI/CD or Vault ç®¡ç† client credentials]
				|
				+--> æ³¨å…¥ Auth Server (è¨»å†Š RegisteredClient å­˜ JDBC)
				|
				+--> æ³¨å…¥åˆ° Resource Server (æˆ–å…¶ä»– client) ä½œç‚º OAuth2 èªè­‰ä½¿ç”¨

		ref 3_1_auth_server

client A
	1.è¨­å®š auth server åœ¨å“ª(application.yml)
		client-b:
		  api-url: http://localhost:8082/api
		spring: # by keycloak
		  security:
			oauth2:
			  client:
				registration:
				  keycloak:
					provider: keycloak
					client-id: client-a
					client-secret: my-secret
					authorization-grant-type: client_credentials
				provider:
				  keycloak:
					token-uri: http://localhost:8080/realms/myrealm/protocol/openid-connect/token
		é€™æ¨£ Spring Security çŸ¥é“ Auth Serverï¼ˆKeycloakï¼‰åœ¨å“ªè£¡ï¼Œæœƒè‡ªå‹•å¹«ä½ å–å¾— JWTï¼

		spring: # by è‡ªè¨‚ auth server
		  security:
			oauth2:
			  client:
				registration:
				  '[ä½ çš„è‡ªè¨‚ registration name]':
					client-id: ${CLIENT_ID:hello-client}
					client-secret: ${CLIENT_SECRET:secret123}
					authorization-grant-type: client_credentials
					scope:
					 - read
					provider: jwt-provider         # â† å¿…é ˆå°æ‡‰ provider å€å¡Šçš„ key
				provider:
				  jwt-provider:
					token-uri: http://localhost:9000/auth-server/oauth2/token # å» auth server å–çš„ jwt è‡ªå‹•åŸ‹å…¥
		é€™æ¨£ Spring Security çŸ¥é“è‡ªè¨‚ Auth Server åœ¨å“ªè£¡ï¼Œæœƒè‡ªå‹•å¹«ä½ å–å¾— JWTï¼

	2.ç™¼èµ·è«‹æ±‚åˆ° å¾ AUTH server å–å¾— jwt
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-oauth2-client</artifactId>
		</dependency>
		Client A ç›´æ¥ä½¿ç”¨ OAuth2AuthorizedClientService å–å¾— JWT
			import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;
			import org.springframework.security.oauth2.client.OAuth2AuthorizedClientService;
			import org.springframework.security.oauth2.client.OAuth2AuthorizedClientManager;
			import org.springframework.security.oauth2.client.authentication.OAuth2AuthorizationContext;
			import org.springframework.security.oauth2.core.OAuth2AccessToken;
			import org.springframework.stereotype.Service;
			import org.springframework.web.client.RestTemplate;
			import org.springframework.http.*;

			@Service
			public class ClientAService {

				private final OAuth2AuthorizedClientManager authorizedClientManager;

				public ClientAService(OAuth2AuthorizedClientManager authorizedClientManager) {
					this.authorizedClientManager = authorizedClientManager;
				}

				public String getAccessToken() {
					OAuth2AuthorizedClient authorizedClient = authorizedClientManager.authorize(
							OAuth2AuthorizationContext.withClientRegistrationId("keycloak").principal("client-a").build());

					if (authorizedClient == null || authorizedClient.getAccessToken() == null) {
						throw new IllegalStateException("Unable to obtain access token.");
					}

					return authorizedClient.getAccessToken().getTokenValue();
				}

				public String callClientBApi() {
					String jwtToken = getAccessToken(); // è®“ Spring Security è‡ªå‹•ç®¡ç† JWT

					String clientBApiUrl = "http://localhost:8082/api/orders";  // Client B API
					RestTemplate restTemplate = new RestTemplate();
					HttpHeaders headers = new HttpHeaders();
					headers.set("Authorization", "Bearer " + jwtToken);

					HttpEntity<String> request = new HttpEntity<>(headers);
					ResponseEntity<String> response = restTemplate.exchange(clientBApiUrl, HttpMethod.GET, request, String.class);

					return response.getBody();
				}
			}


	3.ç™¼èµ·è«‹æ±‚åˆ° client B api with jwt
		ä½¿ç”¨ Spring Cloud OpenFeignï¼ˆæ¨è–¦ï¼Œé¿å…æ‰‹å¯« HTTP è«‹æ±‚ï¼‰
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-openfeign</artifactId>
			</dependency>
		å®šç¾© Feign Clientï¼ˆå‹•æ…‹è«‹æ±‚ Client B APIï¼‰
			import org.springframework.cloud.openfeign.FeignClient;
			import org.springframework.web.bind.annotation.GetMapping;

			@FeignClient(name = "clientB", url = "${client-b.api-url}")
			public interface ClientBFeignClient {

				@GetMapping("/api/orders")
				String getOrders();
			}
		ç°¡åŒ–è®Šæˆ
			import org.springframework.security.oauth2.client.OAuth2AuthorizedClientManager;
			import org.springframework.security.oauth2.client.authentication.OAuth2AuthorizationContext;
			import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;
			import org.springframework.security.oauth2.core.OAuth2AccessToken;
			import org.springframework.stereotype.Service;

			@Service
			public class ClientAService {

				private final OAuth2AuthorizedClientManager authorizedClientManager;
				private final ClientBFeignClient clientBFeignClient;

				public ClientAService(OAuth2AuthorizedClientManager authorizedClientManager, ClientBFeignClient clientBFeignClient) {
					this.authorizedClientManager = authorizedClientManager;
					this.clientBFeignClient = clientBFeignClient;
				}

				public String getAccessToken() {
					OAuth2AuthorizedClient authorizedClient = authorizedClientManager.authorize(
							OAuth2AuthorizationContext.withClientRegistrationId("keycloak").principal("client-a").build());

					if (authorizedClient == null || authorizedClient.getAccessToken() == null) {
						throw new IllegalStateException("Unable to obtain access token.");
					}

					return authorizedClient.getAccessToken().getTokenValue();
				}

				public String callClientBApi() {
					String jwtToken = getAccessToken();
					return clientBFeignClient.getOrders(); // é€é Feign å‘¼å« Client B API
				}
			}
			Feign æœƒè‡ªå‹•å¹«ä½ è™•ç† HTTP è«‹æ±‚ï¼Œé¿å…æ‰‹å¯« RestTemplateï¼Œè€Œä¸” URL æ˜¯å‹•æ…‹çš„ï¼

		è®“ Feign Client å¸¶ä¸Š JWT
			æ–¹æ³• 1ï¼šä½¿ç”¨ Feign Request Interceptorï¼ˆæ¨è–¦ï¼‰
				é€é RequestInterceptor è‡ªå‹•ç‚ºæ‰€æœ‰ Feign è«‹æ±‚åŠ ä¸Š JWTï¼Œé€™æ¨£ Feign Client å°±èƒ½å¤ å¸¶ JWT è«‹æ±‚ Client B APIï¼
					import feign.RequestInterceptor;
					import feign.RequestTemplate;
					import org.springframework.context.annotation.Bean;
					import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;
					import org.springframework.security.oauth2.client.OAuth2AuthorizedClientManager;
					import org.springframework.security.oauth2.client.authentication.OAuth2AuthorizationContext;
					import org.springframework.security.oauth2.core.OAuth2AccessToken;
					import org.springframework.stereotype.Component;

					@Component
					public class FeignClientInterceptor implements RequestInterceptor {

						private final OAuth2AuthorizedClientManager authorizedClientManager;

						public FeignClientInterceptor(OAuth2AuthorizedClientManager authorizedClientManager) {
							this.authorizedClientManager = authorizedClientManager;
						}

						@Override
						public void apply(RequestTemplate requestTemplate) {
							String jwtToken = getAccessToken(); // å–å¾— JWT Token
							requestTemplate.header("Authorization", "Bearer " + jwtToken); // è¨­å®š Header
						}

						private String getAccessToken() {
							OAuth2AuthorizedClient authorizedClient = authorizedClientManager.authorize(
									OAuth2AuthorizationContext.withClientRegistrationId("keycloak").principal("client-a").build());

							if (authorizedClient == null || authorizedClient.getAccessToken() == null) {
								throw new IllegalStateException("Unable to obtain access token.");
							}

							return authorizedClient.getAccessToken().getTokenValue();
						}
					}
			æ–¹æ³• 2ï¼šæ‰‹å‹•å‚³é JWT
				import org.springframework.cloud.openfeign.FeignClient;
				import org.springframework.web.bind.annotation.GetMapping;
				import org.springframework.web.bind.annotation.RequestHeader;

				@FeignClient(name = "clientB", url = "${client-b.api-url}")
				public interface ClientBFeignClient {
					@GetMapping("/api/orders")
					String getOrders(@RequestHeader("Authorization") String authorization);
				}

				public class ClientAService {
					....
					public String callClientBApi() {
						String jwtToken = "Bearer " + getAccessToken();  // å–å¾— JWT Token
						return clientBFeignClient.getOrders(jwtToken); // æ‰‹å‹•å‚³é Token
					}
				}

		å¦‚ä½•åœ¨ç·¨è­¯æœŸï¼ˆCompile Timeï¼‰ç™¼ç¾ API è®Šæ›´ï¼Ÿ
			å¦‚æœä½ çš„éœ€æ±‚æ˜¯ åœ¨ç·¨è­¯æœŸï¼ˆCompile Timeï¼‰å°±èƒ½ç™¼ç¾ Client B API çš„ URL è®Šæ›´
				æ–¹æ³• 1ï¼šå®šç¾© API æ¥å£ï¼Œè®“ Client A & Client B å…±äº«
					ä½¿ç”¨ interface ä¾†çµ±ä¸€ API å®šç¾©ï¼Œè®“ Client A å’Œ Client B éƒ½å¼•ç”¨ç›¸åŒçš„ API æè¿°ï¼
						package com.example.common.api;

						import org.springframework.web.bind.annotation.GetMapping;
						import org.springframework.web.bind.annotation.RequestMapping;
						import org.springframework.web.bind.annotation.RestController;

						@RequestMapping("/api/orders")
						public interface OrderApi {

							@GetMapping
							String getOrders();
						}
						é€™æ¨£ API çš„å®šç¾©æ˜¯å…±ç”¨çš„ï¼ŒClient A å’Œ Client B éƒ½è¦å¼•ç”¨é€™å€‹ common-apiï¼
					Client B ä¸­å¯¦ä½œé€™å€‹ API
						@RestController
						public class ClientBController implements OrderApi {

							@Override
							public String getOrders() {
								return "Orders from Client B";
							}
						}
					 Client A çš„ Feign Client ä½¿ç”¨ OrderApi
						import org.springframework.cloud.openfeign.FeignClient;
						import com.example.common.api.OrderApi;

						@FeignClient(name = "clientB", url = "${client-b.api-url}")
						public interface ClientBFeignClient extends OrderApi {
						}
				æ–¹æ³• 2ï¼šä½¿ç”¨ Eureka / Consul æœå‹™è¨»å†Šç™¼ç¾
					å¦‚æœ Client B API è®Šæ›´ï¼Œè®“ Client A è‡ªå‹•ç™¼ç¾æ–°çš„ API ä½å€ï¼Œè€Œä¸éœ€è¦æ‰‹å‹•è¨­å®š URLï¼
						Client B åœ¨ Eureka è¨»å†Š
							spring:
							  application:
								name: client-b
							  cloud:
								discovery:
								  enabled: true
								eureka:
								  client:
									service-url:
									  defaultZone: http://localhost:8761/eureka/
						Client A ä½¿ç”¨ Eureka è¨»å†Šçš„åç¨±ä¾†èª¿ç”¨ Feign
							@FeignClient(name = "client-b")
							public interface ClientBFeignClient extends OrderApi {
							}
							é€™æ¨£ Spring Cloud æœƒè‡ªå‹•æ‰¾åˆ° client-b çš„æœ€æ–° URLï¼Œç„¡éœ€æ‰‹å‹•é…ç½®ï¼
				æ–¹æ³• 3ï¼šä½¿ç”¨ OpenAPI + Code Generation
					... ç•¥
		æœ€ä½³æ–¹å¼æ˜¯ï¼š
			ä½¿ç”¨ æ–¹æ³• 1ï¼ˆå…±ç”¨ API ä»‹é¢ï¼‰ ä¾†ç¢ºä¿ API ç°½åä¸€è‡´ï¼ˆç·¨è­¯æœŸæª¢æŸ¥ï¼‰
			æ­é… æ–¹æ³• 2ï¼ˆEurekaï¼‰ ä¾†é¿å… Client A éœ€è¦æ‰‹å‹•ä¿®æ”¹ URLï¼ˆåŸ·è¡ŒæœŸç™¼ç¾ï¼‰


client B
	1.client B è¨­å®š è®“ Spring Security çŸ¥é“ Auth Serverï¼ˆJWT ç™¼è¡Œè€…ï¼‰ (application.yml)
		spring:
		  security:
			oauth2:
			  resourceserver:
				jwt:
				  issuer-uri: http://localhost:8080/realms/myrealm
		é€™æ¨£ Spring Security æœƒè‡ªå‹•é©—è­‰ JWTï¼Œç¢ºä¿ Token ä¾†è‡ªåˆæ³•çš„ Auth Serverï¼
	2.ä¸¦åœ¨ client B api åƒæ•¸æœ‰ @AuthenticationPrincipal Jwt jwtï¼Œå‰‡ client B æ”¶åˆ°æœƒè‡ªè¡Œè‡ªå‹•é©—è­‰ jwt
		@RestController
		@RequestMapping("/api")
		public class ClientBController {

			@GetMapping("/orders")
			public String getOrders(@AuthenticationPrincipal Jwt jwt) {
				String username = jwt.getClaim("sub");  // å–å¾— JWT å…§çš„ä½¿ç”¨è€…åç¨±
				return "Orders for: " + username;
			}
		}

		ğŸ“Œ ç•¶ Client A ç™¼è«‹æ±‚åˆ° /api/ordersï¼ŒSpring Security æœƒè‡ªå‹•é©—è­‰ JWT
		ğŸ“Œ å¦‚æœ JWT ç„¡æ•ˆï¼ŒSpring Security ç›´æ¥å›å‚³ 401 Unauthorizedï¼Œä¸æœƒåŸ·è¡Œ Controller
		ğŸ“Œ å¦‚æœ JWT æœ‰æ•ˆï¼Œ@AuthenticationPrincipal Jwt jwt æœƒè‡ªå‹•è§£æ JWTï¼Œè®“ API å–å¾—ç”¨æˆ¶è³‡è¨Šï¼


OAuth2 resource server
	Client Credentials æ¨¡å¼ä¸‹
		é€šå¸¸ æ¯å€‹ Backend é€šå¸¸å°±è‡ªå·±æ˜¯ Resource Server
			Frontend â†’ æ‹¿ JWT â†’ Backendï¼ˆè‡ªå·±é©—è­‰ JWTï¼‰
									  â†‘
								acts as Resource Server

		å› ç‚º Client Credentials æ¨¡å¼ çš„ç”¨é€”æœ¬ä¾†å°±åå‘ï¼š
			* æ©Ÿå™¨å°æ©Ÿå™¨çš„å­˜å–
			* ä¸æ¶‰åŠä½¿ç”¨è€…ç™»å…¥
			* æ¯å€‹ backend æœå‹™æœ‰ä¸åŒè·è²¬ï¼ˆå¦‚å ±è¡¨ã€ä»»å‹™æ’ç¨‹ã€ç›£æ§ï¼‰

		è‹¥ä½ æŠŠæ‰€æœ‰ API é›†ä¸­åˆ°ä¸€å€‹ Resource Serverï¼Œæœƒå°è‡´ï¼š
			* å„æ¥­å‹™å¾Œç«¯é«˜åº¦è€¦åˆï¼Œé•åå¾®æœå‹™ç¨ç«‹æ€§
			* è³‡æºç®¡ç†èˆ‡æ¬Šé™æ§ç®¡éƒ½è¦ä¸­å¤®çµ±ä¸€è™•ç†ï¼Œè¤‡é›œåº¦æš´å¢
			* æ–° backend æ¨å‡ºé‚„è¦æ”¹ centralized RSï¼Œä¸åˆ© CI/CD è‡ªåŠ©éƒ¨ç½²

		ref 3_2_Client_Credentials_resource_server

JWT + Refresh Token å¯¦å‹™è¨­è¨ˆ
	é€šå¸¸ JWT æœƒ æ­é… Refresh Tokenï¼Œç¢ºä¿å®‰å…¨æ€§åˆèƒ½æå‡é«”é©—ï¼š
	Token é¡å‹				å­˜åœ¨å“ªè£¡					æœ‰æ•ˆæ™‚é–“		ç”¨é€”
	Access Token (JWT)		å‰ç«¯ (Header)				5-15 åˆ†é˜		æ¯æ¬¡ API è«‹æ±‚æ™‚ä½¿ç”¨
	Refresh Token			Cookie / Secure Storage		7 å¤© - 30 å¤©	ç•¶ Access Token éæœŸæ™‚ï¼Œå–å¾—æ–° JWT
	ğŸ“Œ æµç¨‹
		ç”¨æˆ¶ç™»å…¥ï¼Œå–å¾— Access Token (JWT, 5 åˆ†é˜) å’Œ Refresh Token (7 å¤©)
		å‰ç«¯å¸¶è‘— Access Token è«‹æ±‚ API
		å¦‚æœ Access Token éæœŸï¼Œå‰ç«¯ä½¿ç”¨ Refresh Token å‘å¾Œç«¯è«‹æ±‚æ–° Token
		å¦‚æœ Refresh Token ä¹ŸéæœŸï¼Œå‰‡å¼·åˆ¶ç”¨æˆ¶é‡æ–°ç™»å…¥
	ğŸ“Œ é€™æ¨£çš„è¨­è¨ˆæ¯” Session æ›´å®‰å…¨
		å³ä½¿ Access Token è¢«ç«Šå–ï¼Œ5 åˆ†é˜å¾Œå°±æœƒå¤±æ•ˆ
		Refresh Token å­˜åœ¨ HttpOnly Cookieï¼Œä¸æœƒæš´éœ²åœ¨ JavaScriptï¼Œé™ä½è¢«ç«Šå–çš„é¢¨éšª
		å¦‚æœ Refresh Token ä¹ŸéæœŸ (7 å¤©)ï¼Œå‰‡ç”¨æˆ¶éœ€è¦é‡æ–°ç™»å…¥


å°‡ Spring Security çš„ CSRF Token æ”¹ç‚º JWTï¼Œè‡³å°‘éœ€è¦èª¿æ•´ä»¥ä¸‹å¹¾å€‹é—œéµé»ï¼š
	ğŸš€(1)é—œé–‰ CSRF é˜²ç¦¦
		å› ç‚º CSRF ä¸»è¦é‡å° Session-based èªè­‰ï¼Œè€Œ JWT æ˜¯ç„¡ç‹€æ…‹çš„ï¼Œæ‰€ä»¥å¯ä»¥é—œé–‰ CSRF
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			import org.springframework.security.config.annotation.web.builders.HttpSecurity;
			import org.springframework.security.config.http.SessionCreationPolicy;
			import org.springframework.security.web.SecurityFilterChain;

			@Configuration
			public class SecurityConfig {
				@Bean
				public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
					http
						.csrf(csrf -> csrf.disable())  // âŒ é—œé–‰ CSRFï¼Œå› ç‚ºæˆ‘å€‘æ”¹ç”¨ JWT
						.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // ç„¡ç‹€æ…‹
						.authorizeHttpRequests(auth -> auth
							.requestMatchers("/login", "/register").permitAll()
							.anyRequest().authenticated()
						)
						.oauth2ResourceServer(oauth2 -> oauth2.jwt())  // âœ… å•Ÿç”¨ JWT é©—è­‰
						.build();
				}
			}
			é€™è£¡åšäº†ä»€éº¼ï¼Ÿ
				é—œé–‰ CSRF
				è¨­ç½® SessionCreationPolicy.STATELESS è®“ Spring Security ç„¡ç‹€æ…‹é‹è¡Œ
				å•Ÿç”¨ OAuth2ResourceServer ä¾†é©—è­‰ JWT

	ğŸš€(2)è®“å‰ç«¯å¾ CSRF Token è½‰æ›æˆ JWT
		ğŸ“Œ å‰ç«¯ JavaScript èª¿æ•´
			async function submitForm(event) {
				event.preventDefault(); // é˜»æ­¢è¡¨å–®ç›´æ¥æäº¤

				// å–å¾— JWT (æ¨¡æ“¬æ–¹å¼ï¼Œå¯¦éš›æ‡‰è©²å¾ Auth Server å–å¾—)
				const jwtToken = localStorage.getItem("jwtToken");

				// åœ¨ Header è£¡é™„åŠ  JWT
				const formData = new FormData(event.target);
				const requestOptions = {
					method: event.target.method,
					headers: {
						'Authorization': `Bearer ${jwtToken}`
					},
					body: formData
				};

				// é€å‡ºè¡¨å–®
				fetch(event.target.action, requestOptions)
					.then(response => response.json())
					.then(data => console.log('æˆåŠŸ:', data))
					.catch(error => console.error('éŒ¯èª¤:', error));
			}

			// ç¶å®šè¡¨å–®æäº¤äº‹ä»¶
			document.querySelector("form").addEventListener("submit", submitForm);
		ğŸ“Œ é€™è£¡åšäº†ä»€éº¼ï¼Ÿ

			å‰ç«¯ä¸å†ä½¿ç”¨ X-CSRF-TOKENï¼Œè€Œæ˜¯ Authorization: Bearer <JWT>
			JWT å¯ä»¥å­˜å„²åœ¨ localStorage æˆ– sessionStorageï¼Œé¿å…ä½¿ç”¨ Cookie

	ğŸš€(3)è®“å¾Œç«¯ç™¼æ”¾ JWT
		import org.springframework.security.oauth2.jwt.Jwt;
		import org.springframework.security.oauth2.jwt.JwtEncoder;
		import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
		import org.springframework.stereotype.Service;
		import java.time.Instant;
		import java.util.Map;

		@Service
		public class JwtService {
			private final JwtEncoder jwtEncoder;

			public JwtService(JwtEncoder jwtEncoder) {
				this.jwtEncoder = jwtEncoder;
			}

			public String generateJwt() {
				Instant now = Instant.now();
				long expiry = 300L; // 5 åˆ†é˜æœ‰æ•ˆ

				Jwt jwt = jwtEncoder.encode(JwtEncoderParameters.from(
					claims -> claims
						.issuedAt(now)
						.expiresAt(now.plusSeconds(expiry))
						.claim("type", "form_submission")
				));

				return jwt.getTokenValue();
			}
		}
	ğŸš€(4)å»ºç«‹ API è®“å‰ç«¯å–å¾— JWT
		import org.springframework.web.bind.annotation.GetMapping;
		import org.springframework.web.bind.annotation.RequestMapping;
		import org.springframework.web.bind.annotation.RestController;
		import java.util.Map;

		@RestController
		@RequestMapping("/api")
		public class JwtController {
			private final JwtService jwtService;

			public JwtController(JwtService jwtService) {
				this.jwtService = jwtService;
			}

			@GetMapping("/get-jwt")
			public Map<String, String> getJwt() {
				return Map.of("token", jwtService.generateJwt());
			}
		}

	ğŸš€(5)API ç«¯é©—è­‰ JWT
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import org.springframework.security.config.annotation.web.builders.HttpSecurity;
		import org.springframework.security.config.http.SessionCreationPolicy;
		import org.springframework.security.web.SecurityFilterChain;

		@Configuration
		public class SecurityConfig {
			@Bean
			public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
				http
					.csrf(csrf -> csrf.disable())  // âŒ é—œé–‰ CSRF
					.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // ç„¡ç‹€æ…‹
					.authorizeHttpRequests(auth -> auth
						.requestMatchers("/api/get-jwt").permitAll()
						.requestMatchers("/api/submit").authenticated()
						.anyRequest().denyAll()
					)
					.oauth2ResourceServer(oauth2 -> oauth2.jwt())  // âœ… å•Ÿç”¨ JWT é©—è­‰
					.build();
			}
		}
