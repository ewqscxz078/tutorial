private_key_jwt

client ç«¯æ‰“åˆ° auth server ä¹‹ token request èªè­‰èˆ‡ç”Ÿæˆ jwt éç¨‹

	1. Client ç«¯ï¼ˆé›²å‰ç«¯ï¼‰åœ¨åšä»€éº¼ï¼Ÿ
		ç•¶ä½ ç”¨ private_key_jwt åš client authenticationï¼š
		1.é›²å‰ç«¯ç”¢ç”Ÿä¸€é¡† JWTï¼ˆclient_assertionï¼‰
			header: alg, kidï¼ˆå°æ‡‰ä½ ç§é‘°çš„ key idï¼‰
			claims:
				iss = client_id
				sub = client_id
				aud = token endpoint URL
				jti, exp â€¦ ç­‰é˜²é‡æ”¾

		2.ç”¨è‡ªå·±çš„ private key æŠŠé€™é¡† JWT ç°½èµ·ä¾†ã€‚

		3.å‘¼å« token endpointï¼Œé€ï¼š
			client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer
			client_assertion=<ä¸Šé¢ç°½å¥½çš„ JWT>
			å…¶ä»– grant ç›¸é—œåƒæ•¸ï¼ˆgrant_typeã€scopeã€subject_token â€¦ï¼‰

	2. Auth Server åœ¨åšä»€éº¼ï¼Ÿ
		Auth Server æ”¶åˆ° token requestï¼ˆä¸ç®¡æ˜¯ client_credentials é‚„æ˜¯ token_exchangeï¼‰ï¼Œä½¿ç”¨ private_key_jwt çš„å¤§è‡´æ­¥é©Ÿæ˜¯ï¼š
			1.è§£æ client_assertion é€™é¡† JWTï¼š
				* è®€å‡º kidã€issã€subã€audã€exp â€¦

			2.æ‰¾åˆ°å°æ‡‰çš„ RegisteredClientï¼š
				* é€šå¸¸æ˜¯çœ‹ iss/sub = client_id

			3.ç‚ºäº†é©—è­‰ JWT ç°½ç« ï¼Œéœ€è¦å°æ‡‰çš„ public keyï¼š
				* å¦‚æœé€™å€‹ client çš„ public key æ˜¯ã€Œç›´æ¥å­˜åœ¨ DB / RegisteredClient è£¡çš„ JWKã€
					â†’ ä¸ç”¨æ‰“ä»»ä½• URLï¼Œç›´æ¥æ‹¿å‡ºä¾†é©—ã€‚

				* å¦‚æœé€™å€‹ client æ˜¯è¨­å®š clientSettings.jwkSetUrl = ...
					â†’ Auth Server èƒŒå¾Œæœƒç”¨ä¸€å€‹ JWKS sourceï¼ˆä¾‹å¦‚ Nimbus çš„ RemoteJWKSetï¼‰ï¼š
					* æœƒå…ˆçœ‹ã€Œå¿«å–è£¡æœ‰æ²’æœ‰å°æ‡‰ kid çš„ public keyã€
					* æ²’æœ‰å†å»æ‰“ä¸€æ¬¡ GET {jwkSetUrl}
			4.æ‹¿åˆ° public key å¾Œåš JWT é©—ç«  & claims é©—è­‰ï¼š
				* iss/sub æ˜¯å¦ä¸€è‡´ã€aud æ˜¯å¦æ˜¯ token endpointã€exp æ˜¯å¦æ²’éæœŸã€jti æ˜¯å¦æ²’è¢«é‡ç”¨ï¼ˆå¦‚æœä½ æœ‰åšé˜²é‡æ”¾ï¼‰

			5.é©—è­‰é€šé â†’ client authenticated â†’ æ‰é€²å…¥æ¥ä¸‹ä¾† grant_type çš„é‚è¼¯ï¼Œç”¢ access token / refresh token / exchanged tokenã€‚
	
		ğŸ‘‰ æ‰€ä»¥ã€Œæ‰“ client jwkSetUrlã€é€™ä»¶äº‹ï¼Œåªç™¼ç”Ÿåœ¨ Auth Server é€™ä¸€å´ï¼Œè€Œä¸”é€šå¸¸æœ‰ key cache æ©Ÿåˆ¶ï¼Œä¸æœƒæ¯ä¸€ç­† request éƒ½æ‰“ä¸€æ¬¡ã€‚

	æ‰€ä»¥æ¯”è¼ƒå®Œæ•´çš„èªªæ³•æ˜¯ï¼š
		* Token é‚„åœ¨å‰ç«¯ cache å…§æ™‚ï¼šä¸æœƒæœ‰ token request â†’ ä¸æœƒè·‘ private_key_jwt 
			â†’ è‡ªç„¶ä¹Ÿä¸æœƒæ‰“ jwkSetUrlã€‚

		* æ¯æ¬¡çœŸçš„ç™¼ token request æ™‚ï¼š
			* client ä¸€å®šæœƒé‡æ–°ç°½ä¸€é¡†æ–°çš„ client_assertionï¼ˆprivate_key_jwt ä¸€å®šåŸ·è¡Œï¼‰ã€‚
			* Auth Server ä¸€å®šæœƒé‡æ–°é©—é€™é¡† assertionï¼Œä½†ã€Œæ˜¯å¦çœŸçš„æ‰“ HTTP åˆ° jwkSetUrlã€å‰‡å–æ±ºæ–¼å®ƒçš„ JWKS å¿«å–ç‹€æ³ã€‚


Auth Server key cache æ©Ÿåˆ¶èªªæ˜
	* é è¨­ key cache ä¸»è¦ä¾†è‡ªï¼š
		* Springï¼šJwtClientAssertionDecoderFactory + NimbusJwtDecoder.withJwkSetUri(...)ã€‚
		* Nimbusï¼šRemoteJWKSet + DefaultJWKSetCache(ç´„ 5 åˆ†é˜)ã€‚
	
	* è¦èª¿æ•´ cacheï¼š
		* æœ€å¯¦éš›çš„åšæ³•æ˜¯ è‡ªè¨‚ JwtDecoderFactoryï¼Œç”¨ NimbusJwtDecoder.withJwkSetUri(...).cache(yourSpringCache)ï¼Œ
		* å†é€é JwtClientAssertionAuthenticationProvider#setJwtDecoderFactory(...) æ›é€² Authorization Server configã€‚

Q1 : å¦‚ä½•çœ‹åˆ° client ç«¯ç™¼é€ token request(private_key_jwt) æœ‰ client_assertion_typeã€client_assertion ?
A1 : client_assertion_typeã€client_assertion åœ¨ form body è£¡
		åšæ³• Aï¼šç›´æ¥é–‹ Reactor Netty wiretapï¼ˆæœ€çœäº‹ï¼‰
			å¦‚æœä½ çš„ WebClient æ˜¯ç”¨ Reactor Nettyï¼ˆé è¨­å°±æ˜¯ï¼‰ï¼Œ
			å¯ä»¥é€™æ¨£é–‹ã€Œåº•å±¤ HTTP çš„ debug logã€ï¼ˆåŒ…å« bodyï¼‰ï¼š
			java
				HttpClient httpClient = HttpClient.create()
						.wiretap("reactor.netty.http.client.HttpClient",
								 io.netty.handler.logging.LogLevel.DEBUG,
								 reactor.netty.transport.logging.AdvancedByteBufFormat.TEXTUAL);

				WebClient webClient = WebClient.builder()
						.clientConnector(new ReactorClientHttpConnector(httpClient))
						.build();
			
			application.yml
			  logging:
				level:
				  reactor.netty.http.client.HttpClient: DEBUG

		åšæ³• Bï¼šåœ¨ Auth Server é‚£ä¸€å´çœ‹æ›´æº–ï¼ˆé †ä¾¿é©—è­‰ server æœ‰æ”¶åˆ°ï¼‰
			1.é–‹ Spring çš„ CommonsRequestLoggingFilterï¼š æ¸¬è©¦æ²’æˆåŠŸï¼Œæš«æ™‚ä¸çŸ¥é“å“ªé‚Šå•é¡Œ
				@Bean
				public CommonsRequestLoggingFilter logFilter() {
					CommonsRequestLoggingFilter filter = new CommonsRequestLoggingFilter();
					filter.setIncludeQueryString(true);
					filter.setIncludePayload(true);
					filter.setMaxPayloadLength(10_000);
					filter.setIncludeHeaders(true);
					filter.setAfterMessagePrefix("REQ DATA : ");
					return filter;
				}
			2.æˆ–è‡ªå·±å¯«ä¸€å€‹ OncePerRequestFilterï¼Œåªé‡å° /oauth2/token åš payload logï¼ˆæ¸¬è©¦æ™‚ç”¨ï¼‰ï¼š
				@Component
				public class TokenEndpointLoggingFilter extends OncePerRequestFilter {

					private static final Logger log = LoggerFactory.getLogger(TokenEndpointLoggingFilter.class);

					@Override
					protected void doFilterInternal(HttpServletRequest request,
													HttpServletResponse response,
													FilterChain filterChain)
							throws ServletException, IOException {

						if ("/oauth2/token".equals(request.getRequestURI())
								&& "POST".equalsIgnoreCase(request.getMethod())) {

							CachedBodyHttpServletRequest wrapped = new CachedBodyHttpServletRequest(request);
							String body = new String(wrapped.getInputStream().readAllBytes(), request.getCharacterEncoding());
							log.info("Token request body: {}", body);

							filterChain.doFilter(wrapped, response);
						} else {
							filterChain.doFilter(request, response);
						}
					}
				}
			
		åšæ³• Cï¼šç¡¬è¦åœ¨ WebClient çš„ filter è£¡çœ‹ bodyï¼ˆæ¯”è¼ƒéº»ç…©ï¼‰
			..... ç•¥
	
	ç”Ÿç”¢ç’°å¢ƒè¦å°å¿ƒ log æ•æ„Ÿè³‡è¨Š
		client_assertion æ˜¯ä¸€é¡†ç°½å¥½çš„ JWTï¼Œè£¡é¢é›–ç„¶ã€Œæ²’æœ‰ client secretã€ï¼Œä½†ï¼š
			* å®ƒå¯ä»¥è¢«é‡æ”¾ï¼ˆå¦‚æœæ²’åš jti é˜²é‡æ”¾ï¼‰
			* å®ƒåŒ…å« client_idã€audã€exp ç­‰è³‡è¨Šï¼Œå®‰å…¨ä¸Šé‚„æ˜¯æ•æ„Ÿ
		æ‰€ä»¥é€™ç¨® logï¼š
			* å»ºè­°åªåœ¨ local / test / debug ç’°å¢ƒé–‹
			* æˆ–æ˜¯å°ä¹‹å‰å…ˆåš maskingï¼ˆä¾‹å¦‚æŠŠ JWT åªå°å‰ 20 å­—ã€å¾Œ 10 å­—ï¼‰

Q2: Auth Server æˆ‘æ€éº¼ç¢ºèªå®ƒæœ‰ä¾æ“š private_key_jwt æ¨¡å¼ è§£æ client_assertion é€™é¡† JWT ?
A2: 1. HTTP å±¤ï¼šç¢ºèª request å°±æ˜¯èµ° private_key_jwt
		* client ç«¯æ‰“å° log
	2. è¡Œç‚ºå±¤ï¼šç”¨ã€Œåˆ»æ„å¼„éŒ¯ã€çš„æ–¹å¼é©—è­‰ Auth Server æœ‰åœ¨è§£æ JWT
		1.æŠŠ client çš„ JWK æ•…æ„å¼„éŒ¯ï¼ˆä¾‹å¦‚æ›å¦ä¸€çµ„ keyï¼‰
		2.æŠŠ client_assertion_type æ‹¿æ‰æˆ–æ”¹éŒ¯å­—
		3.æŠŠ JWT çš„ aud claim æ”¹æ‰ï¼ˆä¸è¦å° token endpointï¼‰
	3. ç¨‹å¼å±¤ï¼šç›´æ¥åœ¨ Auth Server è£¡ã€ŒæŠ“ã€ private_key_jwt provider æœ‰æ²’æœ‰è¢«ç”¨åˆ°
		1.ç”¨å®˜æ–¹æä¾›çš„ authenticationProviders(...) hook
		2.ä¹Ÿå¯ä»¥åœ¨ JwtDecoderFactory è£¡ logã€Œæœ‰åœ¨ decode client_assertionã€
	4. debug æ¨¡å¼ 
		JwtClientAssertionAuthenticationProvider.authenticate(...) æ˜¯æœ€å¿«é€Ÿæ–¹å¼
		