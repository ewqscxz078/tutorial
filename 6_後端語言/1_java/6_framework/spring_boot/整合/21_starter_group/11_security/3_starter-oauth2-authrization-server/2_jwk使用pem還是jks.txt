ref ChatGPT

1. 兩種方式的差異
	PEM (.pem / .key / .crt)
		* 內容：Base64 編碼的純文字檔案，通常包含 RSA/ECDSA 的私鑰、公鑰、憑證。
		優點
			* 開放標準（X.509 / PKCS#8），跨語言、跨平台相容性最高。
			* 直接能被 nginx、Apache、Spring、Java、Node.js 等讀取。
			* 適合 容器化、雲端部署，因為可以輕易透過 Secret Manager 或 Vault 掛載。
		缺點
			* 檔案管理上需要注意權限（私鑰不可洩漏）。
			* 沒有內建 password 保護（雖然可以用 openssl 轉成加密的 PEM）。

	JKS (.jks / .p12)
		* 內容：Java KeyStore，Java 世界專用的 keystore 格式，裡面可以存私鑰與憑證鏈。
		* 優點
			* Java 原生支援，KeyStore API 直接讀取。
			* 可以設定 keystore password 與 key password，比單純 PEM 多一層保護。
			* 傳統 Java 生態常用（Tomcat、Spring Security 舊版範例）。
		* 缺點
			* 幾乎只有 JVM 生態支援，不易跨語言。
			* 若將系統雲原生化（Kubernetes、Docker），JKS 不方便與其他服務共用（大多服務都吃 PEM 格式）。
			* 需要透過 keytool 或 openssl 轉換，增加維運負擔。

2. 在 OAuth2 Authorization Server 的情境
	* JWT 簽署用的 JWK (JSON Web Key)
		Spring Authorization Server 最後需要的是 JWK (JSON Web Key Set, JWKS)，不論 PEM 或 JKS，最終都會轉換成 JWK 提供給 Resource Server / Client 驗證。

	* 實務建議
		* 雲端 / Kubernetes / Docker 化環境 → 建議 PEM
			因為 PEM 在不同語言與工具間相容度最好，也方便跟 Vault / Secrets Manager 整合。
			例如：
				spring:
				  security:
					oauth2:
					  authorizationserver:
						jwt:
						  key:
							location: classpath:keys/private.pem

		* 傳統純 JVM 環境（on-prem + Tomcat / JBoss） → 可以用 JKS
			如果你整個系統只會在 Java 環境運行，而且現有 CI/CD/Infra 都習慣 keystore，JKS 也沒問題。

3. 綜合建議
	* 新專案、雲原生 → 用 PEM（未來維運簡單，跟其他服務相容性高）
	* 舊專案、純 Java 生態 → JKS 也可以（維持一致性）
	* 不管哪種，正式區都建議自行產生與管理（不要依賴 Spring Boot 預設隨機產生的金鑰）。
	* 金鑰管理建議放 Vault 或 Secret Manager，避免硬編碼/直接放 repo。