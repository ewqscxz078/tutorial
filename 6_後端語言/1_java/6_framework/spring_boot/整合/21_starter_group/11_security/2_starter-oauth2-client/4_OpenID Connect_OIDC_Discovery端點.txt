ref ChatGPT

「OIDC Discovery」在 人機互動式 (authorization_code) 與 M2M (client_credentials) 模式下，行為與適用範圍是不同的。


一、什麼是「OIDC Discovery 自動補齊 provider」
	OpenID Connect (OIDC) 規範定義了「Discovery」端點：
		GET /.well-known/openid-configuration

	這個端點會回傳一份 JSON 描述檔，包含這個 issuer 的所有 OAuth2 / OIDC 端點，例如：
		{
		  "issuer": "https://auth.example.com",
		  "authorization_endpoint": "https://auth.example.com/oauth2/authorize",
		  "token_endpoint": "https://auth.example.com/oauth2/token",
		  "userinfo_endpoint": "https://auth.example.com/oauth2/userinfo",
		  "jwks_uri": "https://auth.example.com/oauth2/jwks",
		  "grant_types_supported": ["client_credentials", "authorization_code", "refresh_token"],
		  ...
		}

	Spring Security 提供了：
		ClientRegistrations.fromIssuerLocation("https://auth.example.com")
	它會：
		1.自動呼叫上面這個 .well-known/openid-configuration；
		2.自動解析並填入 authorizationUri、tokenUri、jwkSetUri 等；
		3.讓你不需要在 YAML 裡一一指定 authorization-uri、token-uri。


二、M2M（client_credentials）模式也能用嗎？
	✅ 可以用，而且很推薦。
		原因如下：
			* 雖然 M2M 不會用到 authorization_endpoint 或 userinfo_endpoint，
				但它仍然需要 token_endpoint 與 jwks_uri（用於驗證簽章）。
			* fromIssuerLocation() 自動補齊後，就能確保你的 client 永遠抓到 Auth Server 實際的 endpoint，不怕 URL 改變。
			* 這樣你的 client YAML 不需要重複寫一堆 URL，只要提供 issuer 即可。


三、M2M 實際例子
	假設你的 Auth Server 是
		https://auth.local:9000

	而它的 Discovery endpoint 是：
		https://auth.local:9000/.well-known/openid-configuration

	✅ client 端設定（簡潔版）
		client:
		  catalog:
			issuers:
			  - alias: local-as
				issuerUri: https://auth.local:9000
			registrations:
			  - alias: local-as
				clientId: svc-orders
				grantType: client_credentials

	✅ Java 端自動補齊 (透過 OIDC Discovery)
		var builder = ClientRegistrations.fromIssuerLocation("https://auth.local:9000")
			.registrationId("local-as:svc-orders")
			.clientId("svc-orders")
			.clientSecret("super-secret")
			.authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
			.scope("orders.read");

		var registration = builder.build();
	Spring 自動會：
		* 呼叫 https://auth.local:9000/.well-known/openid-configuration
		* 把 token_endpoint 自動補進來（例如 /oauth2/token）
		* 把 jwkSetUri 自動補進來（例如 /oauth2/jwks）
		你完全不需要手動指定 token-uri。

四、什麼情況不能用 OIDC Discovery
	1.Auth Server 沒有實作 .well-known/openid-configuration
		* 舊版 WSO2 / Keycloak / 自行開發的 OAuth Server 若沒提供這個 endpoint，會報錯。
		* 此時你要手動建 ClientRegistration.withRegistrationId(...)，明確設定 tokenUri(...)。

	2.Auth Server 在公司內部的特殊 Gateway 下，無法直接對外提供 Discovery
		* 例如外層 gateway 有 /gw/oauth2/token 但沒有 /gw/.well-known/openid-configuration。

	在這些情況，就得改用手動指定：
		ClientRegistration.withRegistrationId("local-as:svc-orders")
			.tokenUri("https://auth.local:9000/oauth2/token")
			.clientId("svc-orders")
			.clientSecret("secret")
			.authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
			.build();


五、實務建議（針對你這套三件式架構）
	| 環境                  | 是否建議使用 OIDC Discovery | 理由                                                              |
	| -------------------- | ----------------------- | --------------------------------------------------------------- |
	| **本機 / 開發環境**     | ✅ 建議使用                | Auth Server 與 Client 都自己啟，URI 穩定且能自動同步 endpoint                 |
	| **內部部署 (on-prem)** | ⚠ 視情況                 | 若 gateway 封住 `.well-known` 路徑，就要改成手動 URI                        |
	| **雲端 Gateway 模式**  | ✅ 推薦使用                | 雲端環境中通常會 expose `/well-known/openid-configuration` 給外部 client 用 |

六、小結
	| 項目                                           | 是否適用 M2M | 用途                             |
	| --------------------------------------------- | -------- | ------------------------------ |
	| `.well-known/openid-configuration`            | ✅ 適用     | 自動取得 token endpoint / jwks_uri |
	| `ClientRegistrations.fromIssuerLocation(...)` | ✅ 適用     | 自動生成完整的 ClientRegistration     |
	| `userinfo_endpoint`                           | ❌ 不適用    | M2M 不需要                        |
	| `authorization_endpoint`                      | ❌ 不適用    | M2M 不需要                        |
