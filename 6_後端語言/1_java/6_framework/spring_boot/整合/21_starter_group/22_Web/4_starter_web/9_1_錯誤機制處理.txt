ref https://www.baeldung.com/exception-handling-for-rest-with-spring

Exception Handling with Spring for a REST API.

1.各種版本與情境處理 rest exception
	Before Spring 3.2
		in a Spring MVC application
			HandlerExceptionResolver class
			@ExceptionHandler annotation
			但皆有明顯的缺點

	Since 3.2
		@ControllerAdvice annotation
			處理上述兩點的缺點
				促進整個應用程式的統一異常處理，但只管「Spring MVC 世界裡的例外」

	Spring 5
		ResponseStatusException 類別
			在 REST API 中進行基本錯誤處理的快速方法。

2.rest exception
	2.1 : the Controller-Level @ExceptionHandler
		僅對特定的控制器有效，而不是對整個應用程式全域有效
			public class FooController{

				//...
				@ExceptionHandler({ CustomException1.class, CustomException2.class })
				public void handleException() {
					//
				}
			}
		雖然可以透過將其寫在父類別繼承讓其統一，但可能有其他已存在的 base controller ，且該類在另一個jar中或不可修改的問題

	2.2 : HandlerExceptionResolver
		提供一個針對性的異常處理機制
			spring 已提供的實作
				ExceptionHandlerExceptionResolver
					in Spring 3.1 and is enabled by default in the DispatcherServlet
					其實也就是 @ExceptionHandler 實作

				DefaultHandlerExceptionResolver
					in Spring 3.0, and it’s enabled by default in the DispatcherServlet.
						用於將標準 Spring 異常解析為其相應的 HTTP 狀態代碼，即客戶端錯誤 4xx 和伺服器錯誤 5xx 狀態代碼。
						這是它處理的 Spring 異常的完整列表以及它們如何映射到狀態代碼。

						雖然它確實正確設定了回應的狀態代碼，但一個限制是它不會為回應正文設定任何內容。
						對於 REST API（狀態代碼實際上不足以向客戶端提供足夠的資訊），回應還必須有一個正文，
						以允許應用程式提供有關失敗的附加資訊。

						可以透過ModelAndView配置視圖解析度並渲染錯誤內容來解決，但該解決方案顯然不是最優的。
						這就是為什麼 Spring 3.2 引入了一個更好的選項

				ResponseStatusExceptionResolver
					in Spring 3.0 and is enabled by default in the DispatcherServlet.
						主要職責是使用自訂異常上可用的@ResponseStatus註釋並將這些異常映射到HTTP狀態代碼。
							@ResponseStatus(value = HttpStatus.NOT_FOUND)
							public class MyResourceNotFoundException extends RuntimeException {
								public MyResourceNotFoundException() {
									super();
								}
								public MyResourceNotFoundException(String message, Throwable cause) {
									super(message, cause);
								}
								public MyResourceNotFoundException(String message) {
									super(message);
								}
								public MyResourceNotFoundException(Throwable cause) {
									super(cause);
								}
							}
						與 DefaultHandlerExceptionResolver 相同，此解析器在處理回應正文的方式上受到限制 -
						它確實將狀態代碼映射到回應上，但正文仍然為空

				 Custom HandlerExceptionResolver(AbstractHandlerExceptionResolver)
					基於上述兩個 class 無法控制回應的正文。
					理想情況下，我們希望能夠輸出 JSON 或 XML，這取決於客戶端要求的格式（透過 Accept 標頭）。
					僅此一點就證明創建一個新的自訂異常解析器是合理的：
						@Component
						public class RestResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver {

							@Override
							protected ModelAndView doResolveException(
							  HttpServletRequest request,
							  HttpServletResponse response,
							  Object handler,
							  Exception ex) {
								try {
									if (ex instanceof IllegalArgumentException) {
										return handleIllegalArgument(
										  (IllegalArgumentException) ex, response, handler);
									}
									...
								} catch (Exception handlerException) {
									logger.warn("Handling of [" + ex.getClass().getName() + "]
									  resulted in Exception", handlerException);
								}
								return null;
							}

							private ModelAndView
							  handleIllegalArgument(IllegalArgumentException ex, HttpServletResponse response)
							  throws IOException {
								response.sendError(HttpServletResponse.SC_CONFLICT);
								String accept = request.getHeader(HttpHeaders.ACCEPT);
								...
								return new ModelAndView();
							}
						}
					有其限制：它與低階 HtttpServletResponse 交互，並且適合使用 ModelAndView 的舊 MVC 模型，因此仍有改進的空間

	2.3 : @ControllerAdvice
		Spring 3.2 brings support for a global @ExceptionHandler with the @ControllerAdvice annotation
			@ControllerAdvice 註解允許我們將先前的多個分散的 @ExceptionHandler 合併到一個全域錯誤處理元件中
			它使我們能夠完全控制響應正文以及狀態代碼。
			它提供了多個異常到同一方法的映射，以便一起處理。
			它充分利用了較新的 RESTful ResponseEntity 響應。
			這裡要記住的一件事是將使用 @ExceptionHandler 聲明的異常與用作方法參數的異常相匹配。

			@ControllerAdvice
			public class RestResponseEntityExceptionHandler
			  extends ResponseEntityExceptionHandler {

				@ExceptionHandler(value
				  = { IllegalArgumentException.class, IllegalStateException.class })
				protected ResponseEntity<Object> handleConflict(
				  RuntimeException ex, WebRequest request) {
					String bodyOfResponse = "This should be application specific";
					return handleExceptionInternal(ex, bodyOfResponse,
					  new HttpHeaders(), HttpStatus.CONFLICT, request);
				}
			}

			注意:若沒有匹配的 exception 則編譯與 spring 不會有任何錯誤
			但執行期時會
				java.lang.IllegalStateException: No suitable resolver for argument [0] [type=...]
				HandlerMethod details: ...


	2.4 : ResponseStatusException (Spring 5 and Above)
		@GetMapping(value = "/{id}")
		public Foo findById(@PathVariable("id") Long id, HttpServletResponse response) {
			try {
				Foo resourceById = RestPreconditions.checkFound(service.findOne(id));

				eventPublisher.publishEvent(new SingleResourceRetrievedEvent(this, response));
				return resourceById;
			 }
			catch (MyResourceNotFoundException exc) {
				 throw new ResponseStatusException(
				   HttpStatus.NOT_FOUND, "Foo Not Found", exc);
			}
		}



3.Handle the Access Denied in Spring Security
	當經過身份驗證的使用者嘗試存取他沒有足夠權限存取的資源時，就會發生存取被拒絕的情況。

	3.1 : REST and Method-Level Security
		handle Access Denied exception thrown by method-level security annotations –
			@PreAuthorize
			@PostAuthorize
			@Secure

		@ControllerAdvice
		public class RestResponseEntityExceptionHandler
		  extends ResponseEntityExceptionHandler {

			@ExceptionHandler({ AccessDeniedException.class })
			public ResponseEntity<Object> handleAccessDeniedException(
			  Exception ex, WebRequest request) {
				return new ResponseEntity<Object>(
				  "Access denied message here", new HttpHeaders(), HttpStatus.FORBIDDEN);
			}

			...
		}

4.Spring Boot Support
	ErrorController implementation to handle errors in a sensible way.
		瀏覽器提供後備錯誤頁面（也稱為 Whitelabel 錯誤頁面），並為 RESTful、非 HTML 請求提供 JSON 回應
			{
				"timestamp": "2019-01-17T16:12:45.977+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "Error processing the request!",
				"path": "/my-endpoint-with-exceptions"
			}

		可透過可控配置做適當的調整
			server.error.whitelabel.enabled
			server.error.include-stacktrace
			server.error.include-message

		透過在上下文中包含 ErrorAttributes bean 來自定義要在回應中顯示的屬性。
		我們可以擴展 Spring Boot 提供的 DefaultErrorAttributes 類別來讓事情變得更簡單
			@Component
			public class MyCustomErrorAttributes extends DefaultErrorAttributes {

				@Override
				public Map<String, Object> getErrorAttributes(
				  WebRequest webRequest, ErrorAttributeOptions options) {
					Map<String, Object> errorAttributes =
					  super.getErrorAttributes(webRequest, options);
					errorAttributes.put("locale", webRequest.getLocale()
						.toString());
					errorAttributes.remove("error");

					//...

					return errorAttributes;
				}
			}

		如果我們想進一步定義（或覆寫）應用程式如何處理特定內容類型的錯誤，我們可以註冊一個 ErrorController bean。
		同樣，我們可以利用 Spring Boot 提供的預設 BasicErrorController 來幫助我們。

		例如:自訂應用程式如何處理 XML 端點中觸發的錯誤
			@Component
			public class MyErrorController extends BasicErrorController {

				public MyErrorController(
				  ErrorAttributes errorAttributes, ServerProperties serverProperties) {
					super(errorAttributes, serverProperties.getError());
				}

				@RequestMapping(produces = MediaType.APPLICATION_XML_VALUE)
				public ResponseEntity<Map<String, Object>> xmlError(HttpServletRequest request) {

				// ...

				}
			}


總結
	HandlerExceptionResolver
		ExceptionHandlerExceptionResolver
			1.若要某 controller 局部異常處理
				某 controller
					method 宣告 @ExceptionHandler

		DefaultHandlerExceptionResolver
			將標準 Spring 異常解析為其相應的 HTTP 狀態代碼，即客戶端錯誤 4xx 和伺服器錯誤 5xx 狀態代碼
				正文仍然為空
		ResponseStatusExceptionResolver
			用的@ResponseStatus註釋並將這些異常映射到HTTP狀態代碼
				正文仍然為空


		Custom HandlerExceptionResolver(AbstractHandlerExceptionResolver)
			若上述都還沒有處理到的異常

			2.若要全域 controller 內部異常處理
				使用
					class 宣告 @ControllerAdvice
					method 宣告 @ExceptionHandler



	若上面都沒有接收處理到
		最終異常處理由 ErrorController 相關處理
			例如:
				1. 根本沒進 Spring MVC 的情況
					1-1. 路徑不存在（典型 404）
						預設情況下（Boot 2）：

							你打了一個根本沒有任何 @RequestMapping 的 URL。

							DispatcherServlet 找不到 handler，預設 不會丟 NoHandlerFoundException，而是直接讓容器 sendError(404)。

							容器會做一個 ERROR dispatch 到 /error。

						因此這種 404：

							不會進你的 @ExceptionHandler(Exception.class)；

							會直接由 ErrorController（預設 BasicErrorController）接手 /error。
						
						除非你額外設定：
							spring:
							  mvc:
								throw-exception-if-no-handler-found: true
							並且關掉 DispatcherServlet 的 setThrowExceptionIfNoHandlerFound(false) 預設值，
							才會變成拋 NoHandlerFoundException，此時才有機會被你的 @ExceptionHandler 攔到。
					
					1-2. Static Resource / favicon 這種非 MVC 處理
						* /css/**、/js/**、/favicon.ico、靜態檔案對應不到實體檔案；
						* 或是被 ResourceHttpRequestHandler 處理時發生錯誤，但沒丟到 MVC handler 這邊。
						這些很多時候是 在 HandlerMapping / Resource chain 裡自己處理 / 回 404 / sendError，
						結果一樣：最後由容器把錯誤 forward 到 /error，進 ErrorController，不會跑到你的 Controller 層 @ExceptionHandler。
				
				2. 發生在「Spring MVC 之前」的錯誤
					簡單講：在 DispatcherServlet 還沒處理請求前就爆炸了。
					例如:
						* Tomcat 層面的過濾器 / Servlet 出錯：
							* 某個非 Spring 的 Filter 丟 Exception；
							* Tomcat 處理 request 時就先炸（例如低階 IO 問題）。
						* 你自己註冊了一個 Filter，但不是透過 Spring 的 DelegatingFilterProxy / Boot 自動掛在同一個 DispatcherServlet 鏈上，而是 container 級別的 Filter。

						這些例外通常由 Servlet Container 捕捉，轉成 500 或對應錯誤，再：
							* 呼叫 response.sendError(500) → ERROR dispatch → /error → ErrorController；

							* 你的 @ControllerAdvice 根本沒有機會出場。


				3. sendError(...) / error-page 機制主動導向的錯誤
					有時候錯誤不是「丟 Exception」而是你自己或某個 library 呼叫：
						response.sendError(HttpStatus.FORBIDDEN.value(), "Forbidden");
					這種情況：
						1.Servlet 視這是錯誤，觸發 error-page 流程。
						2.Container 做 ERROR dispatch 到 /error。
						3.Spring Boot 的 ErrorMvcAutoConfiguration 把這種 ERROR dispatch 交給 BasicErrorController。

						過程中沒有任何 Exception 被往上丟到 Controller，所以 @ExceptionHandler(Exception.class) 完全不知道。
				
				4. 回應已經 committed 後才發生的錯誤
					這種比較偏邊緣但也會碰到：
						* Controller 已經開始寫 response，甚至 headers/部分 body 已經送出去了；
						* 後面再發生 Exception（例如 streaming 過程中 IO 出錯）。

					此時：
						* response 其實已經「送出一部分」，再要 forward 到 /error 也來不及了；
						* 通常情況是：log 裡有 Exception，client 得到一個「亂掉 / 中斷的 response」，不是一個正常 /error JSON / HTML；
						* 自然也不會經過你的 @ExceptionHandler 或 ErrorController。

					這類錯誤比較靠 log 排查。
			
				5. 非 MVC Thread 的例外（跟這支 request 不一樣的 thread）
					雖然你這題主要關注 HTTP request，但順帶講一下另一類：

						* 在 @Async method 裡丟出來的 Exception；

						* 排程 @Scheduled 任務丟 Exception；

						* 這些都不是當前 request 處理 thread 上發生的錯誤。

					這類 Exception：

						* 不會進 Spring MVC / DispatcherServlet；

						* 當然也不會觸發 /error，更別說 @ExceptionHandler；

						* 只能靠 log、AsyncUncaughtExceptionHandler 或排程框架的錯誤處理介面去處理。

					只是讓你有個大 picture：@ControllerAdvice 只管「MVC request pipeline 裡的東西」。

實務上要做到：

	*「大部分業務錯誤 → 由 @ControllerAdvice 控制格式」

	*「其餘（404、容器層錯誤）→ 由 /error + 自訂 ErrorAttributes / ErrorController 收尾」

	會是比較完整的一套。