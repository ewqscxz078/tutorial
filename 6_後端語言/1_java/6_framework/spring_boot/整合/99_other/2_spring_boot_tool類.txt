ref ChatGPT

PropertyMapper
	ref https://juejin.cn/post/7225809587675906109
	Spring提供的工具類，主要用於重新賦值，轉換等操作，位於org.springframework.boot.context.properties.PropertyMapper下。

	實體類別Entity轉成DTO類別的操作，通常情況。我們有可以將屬性一個個get出來，在set進去。還有一種就是用BeanUtils工具類別將對應類型的屬性一個個copy進去。

	了解了PropertyMapper之後，我們有多了一個方法轉換了。

	範例 :
		Order to OrderDTO

	@Data
	public class Order {
		private Long id;

		private BigDecimal totalAmout;

		private Integer status;

		private Long userId;

		private LocalDateTime createTime;
	}

	@Data
	public class OrderDTO {
		private Long id;

		private BigDecimal totalAmout;

		private Integer status;

		private Long userId;

		private String createTime;
	}

	具體轉換使用方式
		Order order = new Order();
		order.setId(1L);
		order.setStatus(1);
		order.setTotalAmout(BigDecimal.ONE);
		order.setUserId(100L);
		order.setCreateTime(LocalDateTime.now());

		PropertyMapper propertyMapper = PropertyMapper.get();
		OrderDTO orderDTO = new OrderDTO();
		propertyMapper.from(order::getId).to(orderDTO::setId);
		// 如果from取得的元素不是null，則執行to裡面的動作
		propertyMapper.from(order::getStatus).whenNonNull().to(orderDTO::setStatus);
		propertyMapper.from(order::getUserId).to(orderDTO::setUserId);
		propertyMapper.from(order::getTotalAmout).to(orderDTO::setTotalAmout);
		// 因為Order裡面的createTime是LocalDateTime類型，OrderDTO裡面則是String類型，需要轉換一下
		propertyMapper.from(order::getCreateTime).as(createTime -> {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		return createTime.format(formatter);
		}).to(orderDTO::setCreateTime);

	PropertyMapper常用方法
		<T> Source<T> from(Supplier<T> supplier)：提供值的來源，入參為Supplier
		<T> Source<T> from(T value)：一種重載形式，入參可以為一個物件
		void to(Consumer<T> consumer)：透過將任何未過濾的值傳遞給指定的使用者來完成映射
		<R> R toInstance(Function<T, R> factory)：透過從未過濾的值建立新實例來完成映射
		void toCall(Runnable runnable)：當值還沒有時，透過呼叫指定的方法來完成映射
		<R> Source<R> as(Function<T, R> adapter)：將T類型的入參轉成R類型的出參，類似Stream中的map
		Source<T> when...：這一系列方法，都是過濾用的。在from後面調用，如果滿足條件，就直接to方法
		static PropertyMapper get()：提供PropertyMapper實例
		PropertyMapper alwaysApplyingWhenNonNull()：提供實例時，目前實例就過濾掉from之後是null的元素。 PropertyMapper.get().alwaysApplyingWhenNonNull();
		PropertyMapper alwaysApplying(SourceOperator operator)：自訂過濾規則，參考程式碼

			PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplying(new PropertyMapper.SourceOperator() {
				@Override
				public <T> PropertyMapper.Source<T> apply(PropertyMapper.Source<T> source) {
					return source.when(t -> t instanceof LocalDateTime);
				}
			});

			目前 PropertyMapper只會對應 LocalDateTime類型的欄位。

			注意：如果from方法後面有when條件，則alwaysApplying中設定的初始化提交將會失效。


objectprovider
	org.springframework.beans.factory.ObjectProvider

	1) 主要用途是：
		1.延遲取得 Bean
		2.可選取得（沒有也不報錯）
		3.取得多個候選 Bean（含排序）
		用來把 DI 寫得更彈性、避免過早初始化或循環依賴、也更好做「有就用、沒有就跳過」的 auto-config 結構。

	2) 你為什麼會需要 ObjectProvider？
		常見痛點：
			* 你想注入某個 Bean，但它可能不存在（可選依賴），例如某些 starter 才會提供的 bean

			* 你不想在 @Configuration 建立時就把一堆 Bean 提前初始化（lazy / on-demand）

			* 你想拿到 同型別的多個 Bean（List<T> 也行，但 ObjectProvider 更彈性，還能延遲）

			* 你想避免一些「建構子注入時就觸發」造成的問題（例如循環依賴、初始化順序）
	
	3) 常用 API（重點就這幾個）
		ObjectProvider<T> 常用方法：

			getIfAvailable()：有就拿，沒有回 null

			getIfAvailable(Supplier<T> defaultSupplier)：有就拿，沒有用你提供的預設

			getIfUnique()：只有在「唯一候選」時才回傳，否則 null

			orderedStream() / stream()：拿到所有候選（通常用 orderedStream() 尊重 @Order / Ordered）
	
	4) 用法示例
		(A) 可選依賴：有就用、沒有就略過
			@Configuration
			class MyConfig {

				@Bean
				MyService myService(ObjectProvider<MyHook> hookProvider) {
					MyHook hook = hookProvider.getIfAvailable(); // 沒有就 null
					return new MyService(hook);
				}
			}

		(B) 沒有就給預設實作（很適合 starter / auto-config）
			@Bean
			MyService myService(ObjectProvider<MyHook> hookProvider) {
				MyHook hook = hookProvider.getIfAvailable(DefaultMyHook::new);
				return new MyService(hook);
			}

		(C) 多個實作：全部串起來（像 Filter/Interceptor/Customizer pipeline）
			@Bean
			Pipeline pipeline(ObjectProvider<Step> steps) {
				List<Step> ordered = steps.orderedStream().toList();
				return new Pipeline(ordered);
			}

		(D) 只有唯一候選才用（避免「多個 bean」時誤選）
			@Bean
			MyService myService(ObjectProvider<MyHook> hookProvider) {
				MyHook hook = hookProvider.getIfUnique(); // 不唯一就 null
				return new MyService(hook);
			}

	5) 跟 @Autowired(required=false) / Optional<T> / List<T> 差在哪？
		* Optional<T>：只能表達「0 或 1」，但不能優雅處理多個候選，也不強調 ordered

		* List<T>：能拿多個，但通常會在注入點就決定並建立集合；ObjectProvider 更像「我需要時再取」

		* @Autowired(required=false)：舊式寫法，現在通常更推薦 ObjectProvider / Optional