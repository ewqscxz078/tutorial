ã€ŒUser æ¨¡å¼ vs M2M æ¨¡å¼ã€Gateway å‚³éå°ç…§è¡¨
	ğŸŒ Gateway Header å‚³éå°ç…§è¡¨
		| æ¨¡å¼                                                            | JWT å…§å®¹ (Claims)                                      | Gateway é©—è­‰å¾Œå‚³é Header                                                 | å¾Œç«¯ Filter è½‰æ›æˆ Authentication                                                                     | å¾Œç«¯ Security æˆæ¬Šå¯«æ³•                                                                                                                      |
		| -------------------------------------------------------------- | ------------------------------------------------------ | ---------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
		| **User æ¨¡å¼ (OAuth2 Authorization Code / Implicit / Password)** | `sub` (userId), `roles` æˆ– `authorities`, å¯èƒ½æœ‰ `scope` | `X-User-Id: alice`<br>`X-Roles: ROLE_USER,ROLE_ADMIN`                  | `principal = userId ("alice")`<br>`authorities = [ROLE_USER, ROLE_ADMIN]`                             | `.requestMatchers("/admin/**").hasRole("ADMIN")`<br>`.requestMatchers("/user/**").hasAnyRole("USER","ADMIN")`                         |
		| **M2M æ¨¡å¼ (OAuth2 Client Credentials)**                        | `client_id`, `scope` (é€šå¸¸æ²’æœ‰ userId)                   | `X-Client-Id: reporting-service`<br>`X-Scopes: read:orders,write:logs` | `principal = clientId ("reporting-service")`<br>`authorities = [SCOPE_read:orders, SCOPE_write:logs]` | `.requestMatchers("/orders/**").hasAuthority("SCOPE_read:orders")`<br>`.requestMatchers("/logs/**").hasAuthority("SCOPE_write:logs")` |

	ğŸ”¹è¨­è¨ˆé‡é»
		1.Gatewayï¼šçµ±ä¸€è² è²¬ JWT é©—ç°½ï¼ŒåªæŠŠã€Œå¯ä¿¡çš„æœ€å°èº«ä»½è³‡è¨Šã€å‚³çµ¦å¾Œç«¯ã€‚

			* User æ¨¡å¼ â†’ X-User-Id, X-Roles

			* M2M æ¨¡å¼ â†’ X-Client-Id, X-Scopes

		2.å¾Œç«¯ï¼šåªé—œå¿ƒæˆæ¬Š (authZ)ï¼Œä¸åš JWT é©—ç°½ã€‚

			* è‡ªè¨‚ OncePerRequestFilterï¼ŒæŠŠ header è½‰æˆ Authentication æ”¾é€² SecurityContextã€‚

			* SecurityConfig å°±èƒ½ç”¨ hasRole() / hasAuthority() ç›´æ¥å¯«è¦å‰‡ã€‚

		3.å…±ç”¨ Filter è¨­è¨ˆ

			* å¯ä»¥å¯«ä¸€å€‹ Filter åŒæ™‚æ”¯æ´ User æ¨¡å¼ & M2M æ¨¡å¼ï¼š

				* å¦‚æœæœ‰ X-User-Id â†’ ç•¶ä½œ user

				* å¦‚æœæœ‰ X-Client-Id â†’ ç•¶ä½œ client

				* è‡ªå‹•å»ºç«‹å°æ‡‰çš„ Authentication

âœ… ç¸½çµï¼š
	æœå‹™å¯èƒ½åŒæ™‚æœ‰å…©ç¨®èº«ä»½
		1.Resource Server èº«ä»½
			åˆ¥çš„æœå‹™ï¼ˆæˆ–å‰ç«¯ç¶²é ã€æ‰‹æ©Ÿ Appï¼‰æœƒå¸¶ JWT ä¾†æ‰“ä½ çš„ APIã€‚
			ä½ è¦èƒ½é©—è­‰é€™å€‹ JWT â†’ å°±éœ€è¦ï¼š
				ä¿è­·è‡ªå·± API â†’ SecurityFilterChain + http.oauth2ResourceServer(jwt())
		2.OAuth2 Client èº«ä»½
			ä½ é€™å€‹æœå‹™é‚„éœ€è¦å»å‘¼å« å…¶ä»–å—ä¿è­·çš„ APIï¼ˆä¾‹å¦‚å¾Œç«¯ service æˆ–ç¬¬ä¸‰æ–¹ APIï¼‰ã€‚
			é€™æ™‚å€™ä½ è¦è‡ªå·±å» æ‹¿ access tokenï¼ˆç”¨ client_credentials flowï¼‰ï¼Œç„¶å¾Œå¸¶è‘—å»å‘¼å«ã€‚
			é€™å°±æ˜¯ç”¨ï¼š
				å‘¼å«å¤–éƒ¨ API â†’ OAuth2AuthorizedClientManager + WebClient
		3.å…©è€…å…¼æœ‰ï¼ˆå¤§å¤šæ•¸ã€Œå‰ç«¯æœå‹™ / Gatewayã€æƒ…å¢ƒï¼‰ â†’ å…©è€…éƒ½è¦è¨­å®šã€‚

å‰ç«¯(java)
	Spring Security
		user æ¨¡å¼(ä½¿ç”¨è€…ç€è¦½å™¨ç™»å…¥æ¨¡å¼)
			@Bean
			SecurityFilterChain securityFilterChain(final HttpSecurity http) throws Exception {
				http.csrf(csrf -> csrf.disable());
				http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)); // ç„¡ç‹€æ…‹
				//http.authorizeHttpRequests( //
				//		authorize -> authorize.requestMatchers("/call-hello").permitAll() // æ”¾è¡Œ call-hello
				//				.anyRequest().authenticated() //
				//);
				// å•Ÿç”¨ OAuth2 client æ©Ÿåˆ¶ ï¼Œåƒ…é©åˆæœ‰ä½¿ç”¨è€…äº’å‹•ï¼ˆç”¨æˆ¶ç™»å…¥ + http.oauth2Client()æ­£ç¢ºæ–°å¯«æ³•ï¼‰
				// çµ¦ user login flow ç”¨çš„
				http.oauth2Client(withDefaults());

				return http.build();
			}

		m2m æ¨¡å¼(æ©Ÿå™¨å°æ©Ÿå™¨)
			1.Spring Security configuration
				@Bean
				SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
					http.csrf(csrf -> csrf.disable());
					http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)); // ç„¡ç‹€æ…‹
					http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated());
					return http.build();
				}

			2.è¨»å†Š OAuth2AuthorizedClientManager Bean
				@Bean
				public OAuth2AuthorizedClientManager authorizedClientManager(
						ClientRegistrationRepository clientRegistrationRepository,
						OAuth2AuthorizedClientRepository authorizedClientRepository) {

					OAuth2AuthorizedClientProvider authorizedClientProvider =
							OAuth2AuthorizedClientProviderBuilder.builder()
									.clientCredentials() // âœ… machine-to-machine flow
									.build();

					DefaultOAuth2AuthorizedClientManager manager =
							new DefaultOAuth2AuthorizedClientManager(
									clientRegistrationRepository,
									authorizedClientRepository
							);
					manager.setAuthorizedClientProvider(authorizedClientProvider);

					return manager;
				}

			3.æ•´åˆ WebClient (å¸¸è¦‹åšæ³•)
				@Bean
				WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
					ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2 =
							new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);

					return WebClient.builder()
							.apply(oauth2.oauth2Configuration())
							.build();
				}
			4.å‘¼å«æ™‚æŒ‡å®š clientRegistrationId
				ç¯„ä¾‹
					@Service
					public class MyApiClient {
						private final WebClient webClient;

						public MyApiClient(WebClient webClient) {
							this.webClient = webClient;
						}

						public String callApi() {
							return webClient.get()
									.uri("http://localhost:8081/resource")
									.attributes(ServletOAuth2AuthorizedClientExchangeFilterFunction
											.clientRegistrationId("my-client")) // æŒ‡å®š yml è£¡çš„ client id
									.retrieve()
									.bodyToMono(String.class)
									.block();
						}
					}

gateway
	è¦æŠŠ JWT çš„å…§å®¹ï¼ˆuserId / roles / clientId / scopesï¼‰å‚³çµ¦ å¾Œç«¯æœå‹™ï¼Œä½ å¿…é ˆï¼š

		* åœ¨ Gateway å¯« è‡ªè¨‚çš„ Filterï¼ˆä¾‹å¦‚ OncePerRequestFilter æˆ– Gateway çš„ GlobalFilter / WebFilterï¼‰
		* å¾ SecurityContext å–å‡º JwtAuthenticationToken
		* æŠŠéœ€è¦çš„ claimsï¼ˆå¦‚ sub, client_id, roles, scopeï¼‰å¡é€² HTTP Headerï¼Œå† forward çµ¦ä¸‹æ¸¸æœå‹™

	å¾ JwtAuthenticationToken å–å¾— claimsï¼ˆå¦‚ sub, client_id, roles, scopeï¼‰å¡é€² HTTP Headerï¼Œå† forward çµ¦ä¸‹æ¸¸æœå‹™ ç¯„ä¾‹
		@Component
		public class JwtToHeaderFilter extends OncePerRequestFilter {
			@Override
			protected void doFilterInternal(HttpServletRequest request,
											HttpServletResponse response,
											FilterChain filterChain)
					throws ServletException, IOException {

				Authentication auth = SecurityContextHolder.getContext().getAuthentication();

				if (auth instanceof JwtAuthenticationToken jwtAuth) {
					var jwt = jwtAuth.getToken();

					// user æ¨¡å¼ (æœ‰ sub, roles)
					String sub = jwt.getClaimAsString("sub");
					if (sub != null) {
						request.setAttribute("X-User-Id", sub);
						Collection<String> roles = jwt.getClaimAsStringList("roles");
						if (roles != null) {
							request.setAttribute("X-Roles", String.join(",", roles));
						}
					}

					// M2M æ¨¡å¼ (æœ‰ client_id, scope)
					String clientId = jwt.getClaimAsString("client_id");
					if (clientId != null) {
						request.setAttribute("X-Client-Id", clientId);
					}
					Collection<String> scopes = jwt.getClaimAsStringList("scope");
					if (scopes != null) {
						request.setAttribute("X-Scopes", String.join(",", scopes));
					}
				}

				filterChain.doFilter(request, response);
			}
		}



å¾Œç«¯


	å¾ request å–å¾— æˆæ¬Šè³‡è¨Šè½‰æˆ Authenticationï¼ŒSecurityConfig å°æ‡‰æˆæ¬Šè³‡è¨Šè¨­å®šåˆ°å°æ‡‰ uri
		ğŸ”¹å…±ç”¨ Filter ç¯„ä¾‹ (æŠŠ Gateway å‚³é€²ä¾†çš„ Header è½‰æˆ Authentication)
			import jakarta.servlet.FilterChain;
			import jakarta.servlet.ServletException;
			import jakarta.servlet.http.HttpServletRequest;
			import jakarta.servlet.http.HttpServletResponse;
			import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
			import org.springframework.security.core.Authentication;
			import org.springframework.security.core.GrantedAuthority;
			import org.springframework.security.core.authority.SimpleGrantedAuthority;
			import org.springframework.security.core.context.SecurityContextHolder;
			import org.springframework.web.filter.OncePerRequestFilter;

			import java.io.IOException;
			import java.util.*;
			import java.util.stream.Collectors;

			public class GatewayAuthHeaderFilter extends OncePerRequestFilter {

				@Override
				protected void doFilterInternal(HttpServletRequest request,
												HttpServletResponse response,
												FilterChain filterChain) throws IOException, ServletException {

					Authentication authentication = null;

					// 1.User æ¨¡å¼ (æœ‰ User-Id)
					String userId = request.getHeader("X-User-Id");
					String rolesHeader = request.getHeader("X-Roles");

					if (userId != null) {
						List<GrantedAuthority> authorities = Optional.ofNullable(rolesHeader)
								.map(r -> Arrays.stream(r.split(","))
										.map(String::trim)
										.map(role -> role.startsWith("ROLE_") ? role : "ROLE_" + role)
										.map(SimpleGrantedAuthority::new)
										.collect(Collectors.toList()))
								.orElse(List.of());

						authentication = new UsernamePasswordAuthenticationToken(userId, null, authorities);
					}

					// 2.M2M æ¨¡å¼ (æœ‰ Client-Id)
					String clientId = request.getHeader("X-Client-Id");
					String scopesHeader = request.getHeader("X-Scopes");

					if (authentication == null && clientId != null) {
						List<GrantedAuthority> authorities = Optional.ofNullable(scopesHeader)
								.map(s -> Arrays.stream(s.split(","))
										.map(String::trim)
										.map(scope -> scope.startsWith("SCOPE_") ? scope : "SCOPE_" + scope)
										.map(SimpleGrantedAuthority::new)
										.collect(Collectors.toList()))
								.orElse(List.of());

						authentication = new UsernamePasswordAuthenticationToken(clientId, null, authorities);
					}

					// è¨­å®šåˆ° SecurityContext
					if (authentication != null) {
						SecurityContextHolder.getContext().setAuthentication(authentication);
					}

					filterChain.doFilter(request, response);
				}
			}


	ğŸ”¹SecurityConfig ä½¿ç”¨æ–¹å¼
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import org.springframework.security.config.annotation.web.builders.HttpSecurity;
		import org.springframework.security.web.SecurityFilterChain;
		import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

		@Configuration
		public class SecurityConfig {

			@Bean
			SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
				http.csrf(csrf -> csrf.disable());

				// åŠ å…¥æˆ‘å€‘çš„å…±ç”¨ Filter
				http.addFilterBefore(new GatewayAuthHeaderFilter(), UsernamePasswordAuthenticationFilter.class);

				// æˆæ¬Šè¦å‰‡
				http.authorizeHttpRequests(auth -> auth
					// User æ¨¡å¼
					.requestMatchers("/admin/**").hasRole("ADMIN")
					.requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")

					// M2M æ¨¡å¼
					.requestMatchers("/orders/**").hasAuthority("SCOPE_read:orders")
					.requestMatchers("/logs/**").hasAuthority("SCOPE_write:logs")

					.anyRequest().denyAll()
				);

				return http.build();
			}
		}

å¸¸è¦‹å•é¡Œ
	Q1:è¦ç¢ºä¿å¾Œç«¯æœå‹™åƒ…èƒ½ gateway é€²ä¾†ï¼Œä¸ç„¶å¾Œç«¯å¯èƒ½æœƒå› ç‚ºè¢«å‡é€ çš„ header auth æˆæ¬Š æ”»æ“Š?
	A1:ğŸ”’ å¸¸è¦‹ä¿è­·åšæ³•
		1. ç¶²è·¯å±¤éš”é›¢
			* è®“å¾Œç«¯æœå‹™åªé–‹åœ¨å…§ç¶² (private subnet)ï¼Œå°å¤–ä¸å¯ç›´æ¥å­˜å–
			* åªæœ‰ Gateway / API LB å¯ä»¥æ‰“åˆ°å¾Œç«¯

		2. å¯ä¿¡ä¾†æºæª¢æŸ¥
			* å¾Œç«¯æœå‹™åŠ ä¸€å€‹ å…§éƒ¨æ†‘è­‰ headerï¼ˆä¾‹å¦‚ X-Internal-Secretï¼‰
			* Gateway åœ¨ forward æ™‚è‡ªå‹•é™„ä¸Šï¼Œå¾Œç«¯æª¢æŸ¥é€™å€‹ header æ˜¯å¦æ­£ç¢º
			* æ”»æ“Šè€…è‹¥ç›´æ¥æ‰“å¾Œç«¯ï¼Œå› ç‚ºä¸çŸ¥é“é€™å€‹ secretï¼Œå°±è¢«æ‹’çµ•
				X-Internal-Secret: abc123-shared-secret

		3. mTLS (é›™å‘ TLS)
			* Gateway å’Œå¾Œç«¯ä¹‹é–“ä½¿ç”¨ é›™å‘ TLSï¼Œå½¼æ­¤æª¢æŸ¥æ†‘è­‰
			* ç¢ºä¿åªæœ‰æŒæœ‰æ­£ç¢º client cert çš„ Gateway èƒ½æ‰“å¾Œç«¯

		4. Service Mesh / Sidecar ä¿è­·
			* å¦‚æœä½ æœ‰ç”¨ Istio / Linkerd / Consul Connect
			* å¯ä»¥å¼·åˆ¶ æ‰€æœ‰æ±è¥¿éƒ½å¿…é ˆç¶“ç”± Gateway Sidecar æ‰èƒ½é€²å…¥å¾Œç«¯

		ğŸ“Œ ç¸½çµ
			* ä½ çš„ç†è§£æ­£ç¢ºï¼šå¾Œç«¯ä¸é©— JWT â†’ å¿…é ˆä¿¡ä»» Gateway â†’ å¿…é ˆé˜»æ“‹ç›´æ¥è¨ªå•å¾Œç«¯
			* æœ€å°åŒ–åšæ³•ï¼šç¶²è·¯éš”é›¢ + å…§éƒ¨æ†‘è­‰ header
			* é«˜è¦æ ¼åšæ³•ï¼šmTLS / Service Mesh


