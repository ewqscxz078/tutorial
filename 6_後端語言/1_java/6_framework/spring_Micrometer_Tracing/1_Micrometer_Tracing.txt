ref ChatGPT
	https://www.baeldung.com/spring-boot-3-observability
	https://spring.io/blog/2022/10/12/observability-with-spring-boot-3

æ¨™æº–éˆè·¯è¿½è¹¤æ ¼å¼
	W3C Trace Context
		Spring Boot 3 + Micrometer Tracing é è¨­æœƒä¾ç…§ W3C Trace Context æ¨™æº–ï¼Œ
		åœ¨ HTTP Header ä¸Šè‡ªå‹•åŠ ä¸Šä»¥ä¸‹æ¨™é ­ä¾†å‚³é traceId å’Œ spanIdï¼š

åœ¨ Spring Boot 3 ä¸­ï¼Œä½¿ç”¨ Micrometer Tracing ä¾†å¯¦ç¾åˆ†æ•£å¼è¿½è¹¤ï¼ˆDistributed Tracingï¼‰æ˜¯ä¸€å€‹æ¨™æº–åšæ³•ï¼Œ
	Micrometer Tracing æ•´åˆäº†å¦‚ OpenTelemetryã€Braveï¼ˆZipkinï¼‰ã€Wavefront ç­‰å¾Œç«¯ï¼Œä¸¦çµ±ä¸€æä¾›è§€å¯Ÿæ€§æ”¯æŒã€‚

ğŸ”§ åŸºæœ¬æ¶æ§‹èˆ‡å…ƒä»¶
	| åŠŸèƒ½           | å¸¸ç”¨å¯¦ä½œ                            |
	| -------------- | ----------------------------------- |
	| Tracer å¯¦ä½œ    | Braveï¼ˆZipkinï¼‰æˆ– OpenTelemetry     |
	| Span å‚³éå”å®š  | W3C Trace Context (é è¨­)ï¼Œä¹Ÿæ”¯æ´ B3 |
	| å‚³é€è³‡æ–™å¾Œç«¯   | Zipkinã€Jaegerã€OTel Collector ç­‰   |


ä¾è³´
	<dependency>
	  <groupId>org.springframework.boot</groupId>
	  <artifactId>spring-boot-starter-actuator</artifactId>
	</dependency>

    <dependency><groupId>io.micrometer</groupId><artifactId>micrometer-tracing</artifactId></dependency>
	<dependency>
	  <groupId>io.micrometer</groupId>
	  <artifactId>micrometer-tracing-bridge-brave</artifactId>
	</dependency>

	1.ä½¿ç”¨æ–¹å¼
		Observation and ObservationRegistry
			ObservationRegistry observationRegistry = ObservationRegistry.create();
			Observation observation = Observation.createNotStarted("sample", observationRegistry);
			observation.start();
			try (Observation.Scope scope = observation.openScope()) {
				// ... the observed action
			} catch (Exception e) {
				observation.error(e);
				// further exception handling
			} finally {
				observation.stop();
			}

			Or simply:
				observation.observe(() -> {
					// ... the observed action
				});

	2.è¨­å®š MDC Handlerï¼ˆè‹¥æƒ³æŠŠ traceId æ”¾å…¥ MDCï¼‰
		@Bean
		ObservationHandler<Context> mdcHandler() {
			return new MdcObservationHandler();  // 1.4.6 å¾Œè¦æ”¹æˆè‡ªå·±è‡ªè¨‚
		}

		1.4.6 å¾Œ
			ObservationHandler å¾Œè¦æ”¹æˆè‡ªå·±è‡ªè¨‚
				public class SimpleLoggingHandler implements ObservationHandler<Observation.Context> {

					private static final Logger log = LoggerFactory.getLogger(SimpleLoggingHandler.class);

					@Override
					public boolean supportsContext(Observation.Context context) {
						return true;
					}

					@Override
					public void onStart(Observation.Context context) {
						log.info("Starting");
					}

					@Override
					public void onScopeOpened(Observation.Context context) {
						log.info("Scope opened");
					}

					@Override
					public void onScopeClosed(Observation.Context context) {
						log.info("Scope closed");
					}

					@Override
					public void onStop(Observation.Context context) {
						log.info("Stopping");
					}

					@Override
					public void onError(Observation.Context context) {
						log.info("Error");
					}
				}
			å°‡ ObservationHandler è¨»å†Šåˆ° observationRegistry
				è‹¥æ˜¯ spring boot å‰‡å»ºè­°ä½¿ç”¨è‡ªå‹•æ•´åˆè¨»å†Šåˆ° observationRegistry å³å¯
					@Bean
					public ObservationHandler<Observation.Context> mdcHandler() {
						return new SimpleLoggingHandler();
					}
				åä¹‹æ‰‹å·¥æ–¹å¼
					observationRegistry
					  .observationConfig()
					  .observationHandler(new SimpleLoggingHandler());

					For simple logging, an implementation already exists. For instance, to simply log events to the console, we can use
						observationRegistry
						  .observationConfig()
						  .observationHandler(new ObservationTextPublisher(System.out::println));

					To use timer samples and counters, we can configure this:
						MeterRegistry meterRegistry = new SimpleMeterRegistry();
						observationRegistry
						  .observationConfig()
						  .observationHandler(new DefaultMeterObservationHandler(meterRegistry));

						// ... observe using Observation with name "sample"

						// fetch maximum duration of the named observation
						Optional<Double> maximumDuration = meterRegistry.getMeters().stream()
						  .filter(m -> "sample".equals(m.getId().getName()))
						  .flatMap(m -> StreamSupport.stream(m.measure().spliterator(), false))
						  .filter(ms -> ms.getStatistic() == Statistic.MAX)
						  .findFirst()
						  .map(Measurement::getValue);



	3.Spring Integration
		3.1. Actuator
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-actuator</artifactId>
			</dependency>

			It contains an ObservationAutoConfiguration that provides an injectable instance of ObservationRegistry (if it doesnâ€™t already exist), and configures ObservationHandlers for collecting metrics and traces.
			For example, we can use the registry to create a custom observation within a service:
				@Service
				public class GreetingService {

					private ObservationRegistry observationRegistry;

					// constructor

					public String sayHello() {
						return Observation
						  .createNotStarted("greetingService", observationRegistry)
						  .observe(this::sayHelloNoObserver);
					}

					private String sayHelloNoObserver() {
						return "Hello World!";
					}
				}
				@Configuration
				public class ObservationTextPublisherConfiguration {

					private static final Logger log = LoggerFactory.getLogger(ObservationTextPublisherConfiguration.class);

					@Bean
					public ObservationHandler<Observation.Context> observationTextPublisher() {
						return new ObservationTextPublisher(log::info);
					}
				}
		3.2. Web
			For MVC there is a filter (org.springframework.web.filter.ServerHttpObservationFilter) that we can use for HTTP server observations. When Actuator is part of our application, this filter is already registered and active. If not, we need to configure it:
			@Configuration
			public class ObservationFilterConfiguration {

				// if an ObservationRegistry is configured
				@ConditionalOnBean(ObservationRegistry.class)
				// if we do not use Actuator
				@ConditionalOnMissingBean(ServerHttpObservationFilter.class)
				@Bean
				public ServerHttpObservationFilter observationFilter(ObservationRegistry registry) {
					return new ServerHttpObservationFilter(registry);
				}
			}
			For WebFlux, there is such a filter too (org.springframework.web.filter.reactive.ServerHttpObservationFilter), but this has been deprecated since Spring Framework version 6.1 (Spring Boot 3.2). Instead, a WebHttpHandlerBuilder is created. With Actuator, this is auto-configured too.
		3.3. AOP
			The Micrometer Observation API also declares an @Observed annotation with an aspect implementation based on AspectJ. To get this to work, we need to add the AOP dependency to our project:
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-aop</artifactId>
			</dependency>
			@Configuration
			public class ObservedAspectConfiguration {

				@Bean
				public ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
					return new ObservedAspect(observationRegistry);
				}
			}
			@Observed(name = "greetingService")
			@Service
			public class GreetingService {

				public String sayHello() {
					return "Hello World!";
				}
			}
			In combination with Actuator, we can read out the pre-configured metrics (after weâ€™ve invoked the service at least once) using http://localhost:8080/actuator/metrics/greetingService and weâ€™ll get a result like this:
				{
					"name": "greetingService",
					"baseUnit": "seconds",
					"measurements": [
						{
							"statistic": "COUNT",
							"value": 15
						},
						{
							"statistic": "TOTAL_TIME",
							"value": 0.0237577
						},
						{
							"statistic": "MAX",
							"value": 0.0035475
						}
					],
					...
				}
	4.è¨­å®š Logback pattern åŠ å…¥ traceId / spanId
		# application.yml
			logging.pattern.level: "%5p [${spring.application.name},%X{traceId:-},%X{spanId:-}]"


	5.Micrometer Observation æœ‰ä½¿ç”¨æ‰æœƒç”¢ç”Ÿ traceId/spanId
		å¦‚æœä½ ä½¿ç”¨çš„æµç¨‹æˆ–æ§åˆ¶å™¨æ²’æœ‰åŒ…åœ¨ Observation.createNotStarted(...).observe(...) æˆ–æ²’æœ‰ä½¿ç”¨ Web filter è‡ªå‹•èµ· observation scopeï¼ŒMDC ä¹Ÿä¸æœƒæœ‰ traceId/spanIdã€‚
		ğŸ”„ è§£æ³•ï¼š
		Spring Boot Web æœ‰è‡ªå‹•é…ç½® Micrometer çš„è§€å¯Ÿç¯„åœï¼Œä¾‹å¦‚ï¼š
			1.Controller è«‹æ±‚ï¼šè‡ªå‹•å»ºç«‹ Observation
			2.WebClientï¼šè‹¥æœ‰è¨­å®š Tracing ExchangeFilterFunctionï¼Œä¹Ÿæœƒæœ‰ Observation

		ä½†åƒä½ å¦‚æœåœ¨ï¼š
			1.è‡ªè¨‚ thread
			2.é Web è«‹æ±‚æµç¨‹
			3.Scheduler / Batch

			å°±éœ€è¦æ‰‹å‹•å»ºç«‹ observationï¼š
			observationRegistry
				.observation("my.operation")
				.observe(() -> {
					// é€™æ®µæœŸé–“å…§ MDC æ‰æœƒæœ‰ traceId / spanId
					log.info("doing something");
				});

		MDC èˆ‡éåŒæ­¥é‚è¼¯ï¼ˆç‰¹åˆ¥æ˜¯ WebClientï¼‰
			è‹¥ä½¿ç”¨éåŒæ­¥æµç¨‹ï¼ˆä¾‹å¦‚ Mono, CompletableFutureï¼‰ï¼Œè¨˜å¾—ï¼š
			MDC åªåœ¨ åŒä¸€ Thread çš„åŒæ­¥å€å¡Šå…§æœ‰æ•ˆ
			åœ¨ WebClient ä¸­ MDC ä¸æœƒè‡ªå‹•å»¶çºŒï¼Œè¦ç”¨ Tracing Filter
			å»ºè­°ä½¿ç”¨ï¼š
				WebClient.builder()
				  .filter(TracingExchangeFilterFunction.create(tracer)) // Brave æˆ– OTel
				  .build();
				å³ä½¿ WebClient block æ¨¡å¼ï¼Œä»è¦è¨­å®š

		å¤šå€‹ ObservationHandler çš„åŸ·è¡Œé †åº
			å¦‚æœä½ é‚„æœ‰å…¶ä»– ObservationHandlerï¼ŒSpring é è¨­æœƒä¾ç…§ supportsContext(...) è©•ä¼°ä¸¦å‘¼å«ï¼Œæ‰€ä»¥ï¼š
			å»ºè­° MdcObservationHandler æ”¾åœ¨æœ€å¾Œï¼ˆå®ƒé€šå¸¸æ”¯æ´æ‰€æœ‰ contextï¼‰
		âœ… ç¸½çµ Checklist
			| é …ç›®                                             | æ˜¯å¦éœ€è¦                          |
			| ------------------------------------------------ | --------------------------------- |
			| `micrometer-tracing-bridge-brave` æˆ– `-otel`     | âœ… å¿…è¦                           |
			| `micrometer-tracing`ï¼ˆå« MdcObservationHandlerï¼‰ | âœ… å»ºè­°                           |
			| è¨»å†Š MdcObservationHandler                       | âœ… å¿…è¦ï¼ˆSpring Boot ä¸æœƒè‡ªå‹•åŠ ï¼‰ |
			| Logback pattern å« `%X{traceId}`                 | âœ… å¿…è¦                           |
			| ä½¿ç”¨ Micrometer Observation API æˆ– Web è«‹æ±‚      | âœ… traceId æ‰æœƒå‡ºç¾               |
			| éåŒæ­¥ç¨‹å¼æ³¨æ„ MDC å‚³é                          | âœ… éœ€ç‰¹åˆ¥è™•ç†                     |


è‡ªå‹•æ•´åˆï¼š
	Micrometer Tracing API
	Brave ä½œç‚º backend å¯¦ä½œï¼ˆé è¨­ï¼‰
	è‡ªå‹•æ’å…¥ HTTP traceId / spanId åˆ° MDCï¼ˆlogback/log4j2ï¼‰
	è‡ªå‹•è™•ç† Web / WebClient / RestTemplate çš„ tracing propagation

å¦‚æœä½ æƒ³å‚³é€ trace è³‡æ–™ï¼ˆå¦‚åˆ° Zipkinã€OTLPï¼‰å¤šä¾è³´
	å‚³é€åˆ° Zipkin
		<dependency>
		  <groupId>io.zipkin.reporter2</groupId>
		  <artifactId>zipkin-reporter-brave</artifactId>
		</dependency>

		application.yml è¨­å®šç¯„ä¾‹
			management:
			  tracing:
				sampling:
				  probability: 1.0  # å…¨éƒ¨æ”¶é›†ï¼Œå»ºè­°æ­£å¼ç’°å¢ƒè¨­ç‚º 0.1 å·¦å³
			  zipkin:
				tracing:
				  endpoint: http://localhost:9411/api/v2/spans  # Zipkin ä¼ºæœå™¨


	å‚³é€åˆ° OTLP (OpenTelemetry):
		<dependency>
		  <groupId>io.micrometer</groupId>
		  <artifactId>micrometer-tracing-bridge-otel</artifactId>
		</dependency>

		application.yml è¨­å®šç¯„ä¾‹
			management:
			  tracing:
				sampling:
				  probability: 1.0
			otel:
			  exporter:
				otlp:
				  endpoint: http://localhost:4317

	æ­é… exporter
		<dependency>
		  <groupId>io.opentelemetry</groupId>
		  <artifactId>opentelemetry-exporter-otlp</artifactId>
		</dependency>

å°è£œå……ï¼šç‚ºä½•æ²’æœ‰æ‰€è¬‚çš„ spring-boot-starter-micrometer-tracingï¼Ÿ
	Spring Boot åœ˜éšŠå°šæœªæä¾›ä¸€å€‹é€šç”¨çš„ micrometer-tracing starterï¼Œ
	å› ç‚º tracing backend å¤šæ¨£ï¼ˆå¦‚ Braveã€OTelã€Wavefrontã€Datadogï¼‰ï¼Œ
	éœ€è¦é–‹ç™¼è€…é¸æ“‡ä¸€å€‹å¯¦ä½œæ©‹æ¥ä¾è³´ï¼ˆbridgeï¼‰ï¼Œæ‰€ä»¥é€šå¸¸æ˜¯é€é actuator + bridge çš„æ–¹å¼çµ„åˆï¼Œ
	è€Œä¸æ˜¯ä¸€å€‹çµ±ä¸€ starterã€‚




âœ… Micrometer Tracing çš„è‡ªå‹•è¿½è¹¤æ©Ÿåˆ¶
	| å…ƒä»¶                        | æ˜¯å¦è‡ªå‹•å»ºç«‹ spanï¼Ÿ                 | èªªæ˜                                    |
	| --------------------------- | ----------------------------------- | --------------------------------------- |
	| Spring MVC Controller       | âœ…                                  | è‡ªå‹•å»ºç«‹ `http.server.requests` span    |
	| WebClient                   | âœ…                                  | è‡ªå‹•å»ºç«‹ `http.client.requests` span    |
	| RestTemplateï¼ˆè‹¥è¨»å†Šï¼‰      | âœ…                                  | è‡ªå‹•å»ºç«‹ client span                    |
	| RabbitMQ / Kafka / DB é€£ç·š  | ğŸ”„ï¼ˆéœ€ micrometer instrumentationï¼‰ | å¯é¸ç”¨é¡å¤–ä¾è³´å¥—ä»¶                      |
	| æ–¹æ³•å‘¼å«ï¼ˆService å±¤ï¼‰      | âŒ                                  | é è¨­ä¸è¿½è¹¤ï¼Œè¦ç”¨ `@Observed` æˆ–è‡ªè¨‚ AOP |


ğŸ” å°çµå»ºè­°
	| æƒ…å¢ƒ                          | å»ºè­°ä½œæ³•                           |
	| ----------------------------- | ---------------------------------- |
	| REST API æˆ– WebClient å‘¼å«    | Micrometer è‡ªå‹•è™•ç†ï¼Œä¸ç”¨å¯«        |
	| ç‰¹å®š Service æ–¹æ³•è¦å»ºç«‹ span  | `@Observed`                        |
	| è‡ªè¨‚ traceId æ ¼å¼æˆ–ä¸Šä¸‹æ–‡æ•´åˆ | å¯åŠ  AOP æˆ–è‡ªå®š ObservationHandler |


ğŸ§  å¦‚æœä½ ä¸å»ºæ§‹å¾Œç«¯(Zipkinã€OpenTelemetry )æœƒæ€æ¨£ï¼Ÿ
	Micrometer Tracing åœ¨ Spring Boot 3 ä¸­çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯ã€Œå»ºç«‹èˆ‡å‚³é Trace/Spanã€ï¼Œ
	å³ä½¿ä½ ä¸è¨­å®š Zipkin / OTLP ç­‰å¾Œç«¯ï¼Œå®ƒä»ç„¶æœƒï¼š

	âœ… åœ¨æ‡‰ç”¨å…§éƒ¨æ­£å¸¸å·¥ä½œ
		1.è‡ªå‹•å»ºç«‹ HTTP request spanï¼ˆä¾‹å¦‚ controller å‘¼å«ï¼‰

		2.è‡ªå‹•å»ºç«‹ WebClient spanï¼ˆå‘¼å«å…¶ä»–æœå‹™ï¼‰

		3.å°‡ traceId / spanId å‚³éåˆ°ä¸‹æ¸¸æœå‹™ï¼ˆé€é HTTP headerï¼‰

		4.å°‡ traceId / spanId æ”¾é€² MDCï¼Œå¯å°åœ¨ log ä¸­

	âŒ ä½†ä¸æœƒå°‡ trace è³‡æ–™é€å‡ºå»æˆ–é›†ä¸­å±•ç¤º
		é€™è¡¨ç¤ºä½ ç„¡æ³•ï¼š
			1.åœ¨ Zipkin / Jaeger UI ä¸­çœ‹åˆ° span timeline

			2.æŸ¥çœ‹æœå‹™é–“çš„éˆç‹€è¦–è¦ºåŒ–è¿½è¹¤

Micrometer Tracing åªæœƒè‡ªå‹•å¹«ä½ æ”¾ traceId å’Œ spanId åˆ° MDCï¼ˆMapped Diagnostic Contextï¼‰ï¼Œ
	å¦‚æœä½ æœ‰å…¶ä»–è‡ªè¨‚æ¬„ä½ï¼ˆä¾‹å¦‚ userIdã€requestIdã€tenantId ç­‰ï¼‰ï¼Œä½ å¿…é ˆè‡ªè¡Œè£œä¸Šèˆ‡æ¸…é™¤ã€‚

	âœ… Micrometer Tracing é è¨­åªæ”¾é€™äº›é€² MDCï¼š
		| Key       | å€¼ä¾†æº           |
		| --------- | ---------------- |
		| `traceId` | ç•¶å‰ Trace çš„ ID |
		| `spanId`  | ç•¶å‰ Span çš„ ID  |


	ğŸ§  è‹¥ä½ æœ‰é¡å¤–çš„ MDC æ¬„ä½ï¼Œè¦æ€éº¼è£œï¼Ÿ
		æ–¹æ³•ä¸€ï¼šä½¿ç”¨ HandlerInterceptor æˆ– OncePerRequestFilter (ä½†æ¯”è¼ƒå»ºè­° OncePerRequestFilter)
			@Component
			public class CustomMdcInterceptor extends HandlerInterceptorAdapter {

				@Override
				public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
					// å¾ Header æˆ– SecurityContext æŠ“ä½ è¦çš„æ¬„ä½
					String userId = request.getHeader("X-User-Id");
					if (userId != null) {
						MDC.put("userId", userId);
					}
					return true;
				}

				@Override
				public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
					MDC.remove("userId");
				}
			}

	ğŸ“Œ å»ºè­°ç­–ç•¥
		| ç›®çš„                                      | æ–¹æ³•                                     |
		| ----------------------------------------- | ---------------------------------------- |
		| è¦çµ±ä¸€è£œä¸Šè‡ªå®šæ¬„ä½å¦‚ `userId`ã€`reqId`    | ç”¨ `HandlerInterceptor` æˆ– `Filter`      |
		| è¦æ­é… Micrometer çš„è§€å¯Ÿäº‹ä»¶é€²è¡Œ MDC ç®¡ç† | è‡ªå®š `ObservationHandler`                |
		| è¦è‡ªå®š span name ä¸¦æ§åˆ¶å…§å®¹               | ç”¨ `Tracer.nextSpan()` + MDC è™•ç†        |
		| è¦è®“ä¸‹æ¸¸æœå‹™ä¹Ÿçœ‹åˆ°é€™äº›æ¬„ä½                | æ‰‹å‹•å¯«å…¥ HTTP headerï¼ˆé trace contextï¼‰ |


ğŸ¯ Micrometer Tracing çµ¦ä½ çš„æ ¸å¿ƒåƒ¹å€¼æ˜¯ï¼š
	âœ… å¹«ä½ è‡ªå‹•è™•ç† traceId / spanId çš„ç”Ÿæˆã€å‚³éèˆ‡ä¸Šä¸‹æ¸¸ä¸²æ¥
	âœ… è‡ªå‹•åŠ åˆ° MDCï¼ˆä½ å¯ä»¥ç›´æ¥å° logï¼‰
	âœ… è‡ªå‹•å»ºç«‹ spanï¼ˆä¾‹å¦‚ HTTP å‘¼å« / WebClientï¼‰
	âœ… æ”¯æ´è‡ªè¨‚è§€å¯Ÿ / æ‰‹å‹•å»ºç«‹ spanï¼ˆé€²éšæ§åˆ¶ï¼‰

	ğŸ§  ä½† Micrometer Tracingã€Œä¸æœƒå¹«ä½ è™•ç†ã€ï¼š
		| åŠŸèƒ½                                            | æ˜¯å¦ Micrometer Tracing è™•ç†ï¼Ÿ | è™•ç†æ–¹å¼                                          |
		| ----------------------------------------------- | ------------------------------ | ------------------------------------------------- |
		| è‡ªå®š `userId`, `tenantId`, `requestId` ç­‰æ¬„ä½   | âŒ ä¸æœƒ                        | ä½ éœ€è¦ç”¨ Filter / Interceptor / è‡ªå®š Handler è£œä¸Š |
		| ç‰¹å®šæ¥­å‹™æµç¨‹è‡ªå®š spanï¼ˆä¾‹å¦‚æŸ¥è³‡æ–™åº«ã€åŒ¯å‡ºå ±è¡¨ï¼‰ | âŒ é è¨­ä¸æœƒ                    | å¯ç”¨ `@Observed` æˆ– `Tracer.nextSpan()` è™•ç†      |
		| å°‡ traceId å‚³çµ¦é HTTP çš„å…ƒä»¶ï¼ˆå¦‚ MQ, æ—¥èªŒåˆ†æï¼‰| âŒ éœ€ä½ è‡ªè¡Œè™•ç†                | è‡ªè¡Œå¾ `MDC.get("traceId")` æ‹¿ä¾†å‚³é              |

âœ… Micrometer Tracing çš„è§’è‰²å®šä½ç¸½çµå¦‚ä¸‹ï¼š
	| é¡å‹                        | å‚³çµ±åšæ³•ï¼ˆè‡ªå·±å¯«ï¼‰    | Micrometer Tracing     |
	| --------------------------- | --------------------- | ---------------------- |
	| traceId / spanId ç”¢ç”Ÿèˆ‡ç¹¼æ‰¿ | è‡ªå·±å¯« AOP or UUID    | è‡ªå‹•è™•ç†ï¼ˆéµå®ˆæ¨™æº–ï¼‰   |
	| HTTP Header å‚³é            | è‡ªå·±æ‰‹å‹•åŠ             | è‡ªå‹•è™•ç†               |
	| WebClient ä¸‹æ¸¸ä¸²æ¥ Trace    | è‡ªå·±åŠ  Filter         | è‡ªå‹•è™•ç†               |
	| Log MDCï¼ˆæ”¾ traceIdï¼‰       | è‡ªå·±å¡ `MDC.put()`    | è‡ªå‹•å¡å¥½               |
	| è‡ªå®šæ¬„ä½ MDCï¼ˆå¦‚ userIdï¼‰   | è‡ªå·±åŠ                 | é‚„æ˜¯è¦è‡ªå·±åŠ            |
	| Trace å¯è¦–åŒ–å¹³å°æ•´åˆ        | è‡ªå·±ä¸² Zipkin         | å¯é¸é…åˆ exporter      |


ğŸŒ é è¨­ä½¿ç”¨çš„ HTTP Header åç¨±ï¼ˆW3Cï¼‰
	| Header åç¨±     | å…§å®¹                                                                        |
	| --------------- | --------------------------------------------------------------------------- |
	| `traceparent`   | åŒ…å« traceIdã€spanIdã€sampled ç­‰è³‡è¨Š                                        |
	| `tracestate`    | å¯é¸ï¼Œæ”œå¸¶é¡å¤–ä¾›åˆ†æå¹³å°ä½¿ç”¨çš„ vendor-specific è³‡è¨Šï¼ˆå¦‚ datadogã€azure ç­‰ï¼‰ |

	ğŸ§ª traceparent ç¯„ä¾‹å…§å®¹ï¼š
		traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01
					 version-traceId-spanId-sampled
			æ ¼å¼æ‹†è§£ï¼š
				00        -> version
				4bf9...36 -> traceId
				00f0...b7 -> spanId
				01        -> sampled (1 è¡¨ç¤ºæœƒé€åˆ° backend)

	â“å¦‚æœä½ æƒ³æ”¹ç”¨ Zipkin çš„ B3 header æ ¼å¼ï¼Ÿ
		application.ymlï¼š
			management:
			  tracing:
				propagation:
				  type: b3  # æˆ– b3_multi
		B3 å–®ä¸€ headerï¼ˆb3ï¼‰ç¯„ä¾‹ï¼š
			b3: 4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-1
		B3 å¤š headerï¼ˆb3_multiï¼‰ç¯„ä¾‹ï¼š
			X-B3-TraceId: 4bf92f3577b34da6a3ce929d0e0e4736
			X-B3-SpanId: 00f067aa0ba902b7
			X-B3-Sampled: 1


logback mdc è™•ç†æ³¨æ„é …ç›®
	| logback key             | å°æ‡‰å…§å®¹                                           |
	| ----------------------- | -------------------------------------------------- |
	| `%X{traceId}`           | MDC ä¸­çš„ `traceId`ï¼Œç”± Micrometer Tracing è‡ªå‹•æ”¾å…¥ |
	| `%X{spanId}`            | MDC ä¸­çš„ `spanId`ï¼ŒåŒä¸Š                            |
	| `%X{userId}` ç­‰è‡ªå®šæ¬„ä½ | ä½ è¦è‡ªå·±æ”¾ï¼ˆç”¨ Filterã€Interceptorï¼‰               |


================================================================================================================

Q:å¦‚æœä½ åœ¨ã€Œ**æœå‹™å•Ÿå‹•éšæ®µï¼ˆApplication å•Ÿå‹•æ™‚ï¼‰ã€å°±å¸Œæœ›ç”¢ç”Ÿ traceId / spanId ä¸¦å¯«å…¥ log çš„è©±ï¼Œé‚£æ®µç¨‹å¼ç¢¼å¿…é ˆï¼š
	ğŸ“Œ æ‰‹å‹•å»ºç«‹ Observation
	å› ç‚º Spring Boot çš„ Micrometer Tracing åªæœ‰åœ¨ Web è«‹æ±‚ã€Scheduled ä»»å‹™ç­‰ç‰¹å®šæƒ…å¢ƒä¸‹æ‰æœƒè‡ªå‹•å»ºç«‹è§€å¯Ÿç¯„åœï¼Œ
	å°æ–¼ @PostConstruct æˆ– CommandLineRunner ç­‰å•Ÿå‹•ç¨‹å¼å€æ®µï¼Œä¸æœƒè‡ªå‹•ç”¢ç”Ÿ trace contextã€‚

	å¦‚ä½•æ‰‹å‹•å»ºç«‹ Observationï¼ˆå« traceId æ³¨å…¥ MDCï¼‰
		import io.micrometer.observation.Observation;
		import io.micrometer.observation.ObservationRegistry;

		@Slf4j
		@Component
		public class MyStartupRunner implements CommandLineRunner {

			private final ObservationRegistry observationRegistry;

			public MyStartupRunner(ObservationRegistry observationRegistry) {
				this.observationRegistry = observationRegistry;
			}

			@Override
			public void run(String... args) {
				Observation.createNotStarted("app.startup.init", observationRegistry)
					.observe(() -> {
						// MDC ä¸­æ­¤æ™‚æ‰æœƒæœ‰ traceId / spanId
						log.info("åˆå§‹åŒ–é‚è¼¯é–‹å§‹...");
					});
			}
		}

Q:å¦‚ä½•ç¢ºèª è‡ªè¨‚ ObservationHandler ç”Ÿæ•ˆ ?
A:
	@Autowired
	ObservationRegistry registry;

	@PostConstruct
	public void printHandlers() {
		registry.observationConfig().getObservationHandlers()
			.forEach(handler -> System.out.println("Registered: " + handler.getClass()));
	}

Q:é è¨­ç”Ÿæˆçš„ traceId æ˜¯ 32 ä½å…ƒ?
A:
	1. âœ… B3 Propagation æ”¯æ´ 64-bit èˆ‡ 128-bit traceId
		B3ï¼ˆç”± Twitter ç™¼èµ·çš„åˆ†æ•£å¼è¿½è¹¤æ ¼å¼ï¼‰æ˜ç¢ºå®šç¾©ï¼š
		| é¡å‹        | èªªæ˜                        |
		| ----------- | --------------------------- |
		| 64-bit      | 16 å­—å…ƒ hexï¼ˆèˆŠç‰ˆç›¸å®¹æ¨¡å¼ï¼‰ |
		| **128-bit** | **32 å­—å…ƒ hexï¼ˆé è¨­å»ºè­°ï¼‰** |
		Brave æ˜¯ B3 çš„ä¸»è¦å¯¦ä½œï¼Œæ”¯æ´å…©ç¨® traceId æ ¼å¼ï¼Œè€Œ é è¨­å¾ Brave v5 é–‹å§‹æ”¹ç‚º 128-bitã€‚

	2. ğŸ“ˆ 128-bit æä¾›æ›´é«˜ç¢°æ’å®‰å…¨æ€§èˆ‡å”¯ä¸€æ€§
		| ä½å…ƒæ•¸  | æ”¯æ´çš„è¿½è¹¤æ•¸é‡      | æŠ½æ¨£ç¢°æ’æ©Ÿç‡        |
		| ------- | ------------------- | ------------------- |
		| 64-bit  | ç´„ 1.8 Ã— 10Â¹â¹       | ä¸­å¤§å‹ç³»çµ±ä»å¯èƒ½ç¢°æ’ |
		| 128-bit | ç´„ 3.4 Ã— 10Â³â¸       | å¹¾ä¹ä¸å¯èƒ½ç¢°æ’       |
		ç•¶ä½ æœ‰å¤§é‡å¾®æœå‹™ã€ä¸¦è¡Œ trace ç”¢ç”Ÿé‡å¾ˆé«˜æ™‚ï¼ˆä¾‹å¦‚å¤§å‹é›»å•†ã€é‡‘èç³»çµ±ï¼‰ï¼Œ64-bit traceId ç¢°æ’é¢¨éšªé€æ¼¸æˆç‚ºå¯¦éš›å•é¡Œã€‚


Q:æ•´åˆä¾è³´ observationRegistry ä¾è³´æ–¹å¼
A:
	âœ… å°ˆæ¡ˆç”¨é€”ï¼Œä¹Ÿå°±æ˜¯å°ˆæ¡ˆç›´æ¥å®£å‘Šæ–¹æ³•ä¾è³´å³å¯ï¼Œç›´æ¥æ³¨å…¥å°±å¥½ã€‚
		ä»»æ„ spring ioc bean æ³¨å…¥
			@Bean
			MyXXXX myXXXX(ObservationRegistry observationRegistry){
				return new MyXXXX(observationRegistry);
			}

	âœ… è‹¥ä½ å¯«çš„æ˜¯åº•å±¤ Starter/AutoConfigurationï¼Œæ‰éœ€è¦ ObjectProvider<ObservationRegistry> ä¾†å»¶é²å»ºæ§‹ AOP Advisorã€‚
		ä¸ç„¶æœƒé‡åˆ°
			Bean 'xxTaskDefaultPointcutAdvisor' of type [org.springframework.aop.support.DefaultPointcutAdvisor] 																							is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). Is this bean getting eagerly injected/applied to a currently created BeanPostProcessor [healthEndpointGroupsBeanPostProcessor]? Check the corresponding BeanPostProcessor declaration and its dependencies/advisors. If this bean does not have to be post-processed, declare it with ROLE_INFRASTRUCTURE.(org.springframework.context.support.PostProcessorRegistrationDelegate$BeanPostProcessorChecker:437)
			å•é¡Œ

Q:è‡ªè¨‚å…ƒä»¶å•Ÿå‹•èˆ‡ observationRegistry æ•´åˆï¼Œobservation.stop() æœƒ Context does not have an entry for key
	@Component
	public class StartupMdcInitializer {

		private final ObservationRegistry observationRegistry;

		public StartupMdcInitializer(ObservationRegistry observationRegistry) {
			this.observationRegistry = observationRegistry;
		}

		@EventListener(ApplicationReadyEvent.class)
		public void onApplicationReady() {
			Observation observation = Observation.createNotStarted("app-startup", this.observationRegistry)
				.lowCardinalityKeyValue("taskCode", "BOOT001")
				.start();

			try (Observation.Scope scope = observation.openScope()) {
				log.info("å•Ÿå‹•å®Œæˆï¼Œå·²åˆå§‹åŒ– MDC");
			} finally {
				observation.stop();
			}
		}
	}

	åœ¨ observation.stop(); æœƒè·³å‡ºéŒ¯èª¤

	java.lang.IllegalArgumentException: Context does not have an entry for key [class io.micrometer.core.instrument.Timer$Sample]
		at io.micrometer.observation.Observation$Context.getRequired(Observation.java:1062)
		at io.micrometer.core.instrument.observation.DefaultMeterObservationHandler.onStop(DefaultMeterObservationHandler.java:89)
		at io.micrometer.tracing.handler.TracingAwareMeterObservationHandler.onStop(TracingAwareMeterObservationHandler.java:88)
		at io.micrometer.observation.ObservationHandler$FirstMatchingCompositeObservationHandler.onStop(ObservationHandler.java:197)
		at io.micrometer.observation.SimpleObservation.lambda$notifyOnObservationStopped$0(SimpleObservation.java:268)
		at java.base/java.util.ArrayDeque$DescendingIterator.forEachRemaining(ArrayDeque.java:771)
		at io.micrometer.observation.SimpleObservation.notifyOnObservationStopped(SimpleObservation.java:268)
		at io.micrometer.observation.SimpleObservation.stop(SimpleObservation.java:188)
A: æ”¹æˆ Observation.start
	è‹¥ä½¿ç”¨ Observation.createNotStarted å°±è¦è‡ªå·±è£œä¸Š Timer