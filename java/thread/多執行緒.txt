https://dotblogs.com.tw/grayyin/2016/07/04/113501

編寫多執行緒程式是為了實作多工的同步執行，從而能夠更好地提高執行速度。一般有三種方法，
Thread, Runnable, Callable

Runnable和Callable的區別是
(1)Callable規定的方法是call(),Runnable規定的方法是run().
(2)Callable在執行後可返回值，而Runnable在執行後不能返回值
(3)call方法可以拋出異常，run方法不可以
(4)執行Callable會返回Future物件，表示非同步計算的結果。它提供了檢查計算是否完成的方法，
以等待計算的完成，並檢索計算的結果。通過Future物件可以瞭解執行情況，可取消執行，還可獲取執行結果。


Thread oneThread = new Thread( new Runnable(){
@override
public void run(){
      //do something here
    }
});
oneThread.start()


public interface Callable<V> {
    V call() throws Exception;
}
Callable<Integer> oneCallable = new SomeCallable<Integer>();
FutureTask<Integer> oneTask = new FutureTask<Integer>(oneCallable);
Thread oneThread = new Thread(oneTask);
oneThread.start()

================================================== ================================================== ===============================
java.util.concurrent.Executors
已提供常用的幾個模式
newCachedThreadPool創建一個可緩存線程池，如果線程池長度超過處理需要，可靈活回收空閒線程，若無可回收，則新建線程。
newFixedThreadPool 創建一個定長線程池，可控制線程最大並發數，超出的線程會在隊列中等待。
newScheduledThreadPool 創建一個定長線程池，支持定時及週期性任務執行。
newSingleThreadExecutor 創建一個單線程化的線程池，它只會用唯一的工作線程來執行任務，保證所有任務按照指定順序(FIFO, LIFO, 優先級)執行。

1.固定 pool
Executors.newFixedThreadPool

2.單一 pool
Executors.newSingleThreadExecutor

3.週期 pool
Executors.newScheduledThreadPool

4.單一週期 pool
Executors.newSingleThreadScheduledExecutor

5.
Executors.newCachedThreadPool