
windows 11
	使用 wsl with docker compose

建置一個 docker for nginx 的設定

	443 給 /
	1443 給 /auth-server 、 /
	2443 給 /xx-bff
	3443 給 /xx-bn


目錄結構
	nginx-revproxy/
	  docker-compose.yml
	  nginx/
		nginx.conf
		certs/
		  tls.crt
		  tls.key

1) 先產生自簽憑證（WSL 內執行）

	mkdir -p nginx/certs

	openssl req -x509 -nodes -newkey rsa:2048 \
	  -keyout nginx/certs/tls.key \
	  -out nginx/certs/tls.crt \
	  -days 3650 \
	  -subj "/CN=localhost"

2) docker-compose.yml
	services:
	  nginx:
		image: nginx:1.27-alpine
		container_name: nginx-edge
		ports:
		  - "443:443"
		  - "1443:1443"
		  - "2443:2443"
		  - "3443:3443"
		volumes:
		  - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
		  - ./nginx/certs:/etc/nginx/certs:ro
		depends_on:
		  - portal
		  - auth-server
		  - xx-bff
		  - xx-bn
		networks:
		  - appnet

	  # 下面四個先用 http-echo 當假服務佔位，你之後換成自己的 image / container 即可
	  portal:
		image: hashicorp/http-echo:1.0
		command: ["-listen=:8080", "-text=portal OK"]
		networks: [appnet]

	  auth-server:
		image: hashicorp/http-echo:1.0
		command: ["-listen=:8080", "-text=auth-server OK"]
		networks: [appnet]

	  xx-bff:
		image: hashicorp/http-echo:1.0
		command: ["-listen=:8080", "-text=xx-bff OK"]
		networks: [appnet]

	  xx-bn:
		image: hashicorp/http-echo:1.0
		command: ["-listen=:8080", "-text=xx-bn OK"]
		networks: [appnet]

	networks:
	  appnet:
		driver: bridge


3) nginx/nginx.conf
	worker_processes auto;

	events { worker_connections 1024; }

	http {
	  include       /etc/nginx/mime.types;
	  default_type  application/octet-stream;

	  sendfile on;
	  keepalive_timeout 65;

	  # 建議：避免 upstream 服務回傳大 header 時出錯可適度調整
	  proxy_buffer_size 16k;
	  proxy_buffers 8 16k;
	  proxy_busy_buffers_size 32k;

	  # 若你未來要支援 WebSocket
	  map $http_upgrade $connection_upgrade {
		default upgrade;
		''      close;
	  }

	  # ===== upstreams（用 docker compose service name 當 DNS）=====
	  upstream up_portal     { server portal:8080; }
	  upstream up_auth       { server auth-server:9010; }
	  upstream up_gw         { server gateway-server:9111 }
	  upstream up_xx_bff     { server xx-bff:8080; }
	  upstream up_xx_bn      { server xx-bn:8080; }

	  # ===== 共用 proxy headers =====
	  #（用 include 的話要另放檔案；這裡直接寫在 location 內）

	  # ========== 443：/ ==========
	  server {
		listen 443 ssl;
		server_name localhost;

		ssl_certificate     /etc/nginx/certs/tls.crt;
		ssl_certificate_key /etc/nginx/certs/tls.key;

		location / {
		  proxy_pass http://up_portal;
		  proxy_http_version 1.1;

		  proxy_set_header Host $host;
		  proxy_set_header X-Real-IP $remote_addr;
		  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		  proxy_set_header X-Forwarded-Proto https;
		  proxy_set_header X-Forwarded-Port 443;

		  proxy_set_header Upgrade $http_upgrade;
		  proxy_set_header Connection $connection_upgrade;
		}
	  }

	  # ========== 1443：/ 與 /auth-server ==========
	  server {
		listen 1443 ssl;
		server_name localhost;

		ssl_certificate     /etc/nginx/certs/tls.crt;
		ssl_certificate_key /etc/nginx/certs/tls.key;

		# /auth-server/ 明確路徑（保留 prefix /auth-server）
		location /auth-server/ {
		  # 若你的 auth-server 本身「就是掛在根 /」，
		  # 但你希望外部用 /auth-server/ 進來，就用 rewrite 去掉 prefix：
		  #rewrite ^/auth-server/?(.*)$ /$1 break;

		  proxy_pass http://up_auth;
		  proxy_http_version 1.1;

		  proxy_set_header Host $host;
		  proxy_set_header X-Forwarded-Proto https;
		  proxy_set_header X-Forwarded-Port 1443;
		  proxy_set_header X-Forwarded-Prefix /auth-server;

		  proxy_set_header X-Real-IP $remote_addr;
		  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

		  proxy_set_header Upgrade $http_upgrade;
		  proxy_set_header Connection $connection_upgrade;
		}

		# 同一個 1443 的根路徑 / 也導到 auth-server（照你描述）
		location / {
		  proxy_pass http://up_gw;
		  proxy_http_version 1.1;

		  proxy_set_header Host $host;
		  proxy_set_header X-Forwarded-Proto https;
		  proxy_set_header X-Forwarded-Port 1443;

		  proxy_set_header X-Real-IP $remote_addr;
		  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

		  proxy_set_header Upgrade $http_upgrade;
		  proxy_set_header Connection $connection_upgrade;
		}
	  }

	  # ========== 2443：/xx-bff ==========
	  server {
		listen 2443 ssl;
		server_name localhost;

		ssl_certificate     /etc/nginx/certs/tls.crt;
		ssl_certificate_key /etc/nginx/certs/tls.key;

		location / {
		  proxy_pass http://up_xx_bff;
		  proxy_http_version 1.1;

		  proxy_set_header Host $host;
		  proxy_set_header X-Forwarded-Proto https;
		  proxy_set_header X-Forwarded-Port 2443;

		  proxy_set_header X-Real-IP $remote_addr;
		  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

		  proxy_set_header Upgrade $http_upgrade;
		  proxy_set_header Connection $connection_upgrade;
		}
	  }

	  # ========== 3443：/xx-bn ==========
	  server {
		listen 3443 ssl;
		server_name localhost;

		ssl_certificate     /etc/nginx/certs/tls.crt;
		ssl_certificate_key /etc/nginx/certs/tls.key;

		location / {
		  proxy_pass http://up_xx_bn;
		  proxy_http_version 1.1;

		  proxy_set_header Host $host;
		  proxy_set_header X-Forwarded-Proto https;
		  proxy_set_header X-Forwarded-Port 3443;

		  proxy_set_header X-Real-IP $remote_addr;
		  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

		  proxy_set_header Upgrade $http_upgrade;
		  proxy_set_header Connection $connection_upgrade;
		}
	  }
	}

docker compose
	啟動
		docker compose up -d

	確認服務
		docker compose ps -a

	移除docker +image
		docker compose down --rmi local

	看 log
		docker compose logs -f nginx-edge

	啟動 docker 若有問題
		測試確認 docker 內設定狀況，離開就刪除
			docker compose run --rm -it nginx-edge /bin/bash

	進去已啟動的 docker 查看
		docker compose exec nginx bash
		docker compose exec nginx sh

	清除
		作法 A：直接把「舊專案」整套刪掉（最乾淨）
			docker compose ls
			docker compose -p <舊專案名> down
			docker compose -p <舊專案名> down -v
				希望連同舊專案建立的 volumes也一起刪掉（資料會不見）：

		作法 B：你還留著舊的 compose 檔，就用檔案把它刪掉
			docker compose -f <舊docker-compose.yml路徑> down
			docker compose -f <舊docker-compose.yml路徑> down -v // 同樣要刪 volumes：


		作法 C：只刪「已停止」的舊 container（快速清垃圾）
			docker container prune

		作法 D：看 label 精準刪掉某一套 compose 的 container（進階但很準）
			docker ps -a --filter "label=com.docker.compose.project=<舊專案名>"
			docker rm -f $(docker ps -aq --filter "label=com.docker.compose.project=<舊專案名>")
			也想把舊專案的 network 刪掉（通常 down 會一起處理）：
				docker network ls --filter "label=com.docker.compose.project=<舊專案名>"

測：
	curl -k https://localhost/

	curl -k https://localhost:1443/

	curl -k https://localhost:1443/auth-server/

	curl -k https://localhost:2443/

	curl -k https://localhost:3443/